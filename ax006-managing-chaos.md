[оглавление](README.md)

# Давление неизвестности, или как не сгореть, проектируя хаос

В этой и следующей главах мы переходим к чистой психологии, связанной с управлением хаосом,
неизвестностью и системами, сопровождающимися значительным числом недостатков — чем, по сути,
и являются микросервисы.

Начнём в этой главе с неизвестности и хаоса, а в следующей поговорим о легаси,
неполноценностях, кривом спагетти‑коде и остальных прелестях — и о том, как с ними
эффективно работать.

Но сначала — хаос. И здесь мы будем говорить не просто о том, как победить хаос
конкретно в микросервисах, а скорее о том, как изменить своё мышление, чтобы перестать
бояться неопределённости, начать принимать её как данность и двигаться вперёд, сохраняя
рассудок, несмотря на очевидные психологические ловушки, в которые мы все раз за разом
попадаем.

## Связь неизвестности и хаоса с разработкой крупных систем

### Нативная сложность

Сразу хочу ввести очень простую мысль: основная проблема с разработкой сложных систем
буквально заключается в том, что такие системы сложные (сюрприз!) и к ним не подходят
способы разработки простых систем.

Причём, поскольку разработчики — это буквально люди, они все свои психологические
проблемы точно так же перекладывают на эту самую разработку. Из‑за этого мы можем
увидеть ситуацию, в которой разработка просто замирает, будучи окружённой кучей своих
«жертв».

Однако нельзя говорить о том, что проблема нерешаема. Дело в том, что эта «сложность»
на самом деле в большинстве своём — не что иное, как скрытый хаос, несущий с собой такие
вещи, как необъятность, непонятность, иллюзии, невозможность планировать — и следующий
за этим когнитивный паралич.

Можно найти и другие неприятные вещи в этом, однако по сути все основные симптомы и
проблемы сводятся к перечисленным.

Давайте рассмотрим их последовательно, чтобы симптоматика стала очевидной и для вас:

### 1. Попытка объять мозгом необъятное

Первая проблема достаточно проста: человеческий мозг способен оперировать ограниченным
количеством объектов и ограниченным числом шагов (взаимосвязей) между ними. Это легко
понять, если задуматься, можно ли играть в шахматы, просчитывая ходы всё дальше и дальше
вперёд. Нет. Даже для очень талантливых людей это проблематично.

В случае со сложными системами ситуация полностью аналогична: мозг начинает пытаться
просчитывать, как используется и управляется часть Б, — и при этом забывает про
часть А; начинает вспоминать, как работает часть А, — забывает про часть Б.

История предельно понятна. Из неё следует достаточно простой вывод: некоторые системы просто
не предназначены для того, чтобы быть понимаемыми целиком.

Они существуют, они развиваются, но они не понимаемы в том смысле, что нет никого, кто
мог бы их целиком осмыслить и управлять ими, как каким‑то пазлом или чем‑то подобным.

Эта парадоксальная на первый взгляд мысль на самом деле вполне очевидна. Если вы опять же
вернётесь к тем же самым шахматам, то увидите: то, что они не понимаемы и не просчитываемы,
не мешает в них играть — используя паттерны, обобщения и подобное. Об этом мы поговорим
в этой главе дальше, а пока перейдём от понимания к созданию.

### 2. Попытка создать необъятное

Как уже было сказано, некоторые системы создаются такими, что понять их невозможно. Но
человек верит во всемогущество своего мозга и пытается не то чтобы понять такую систему —
он пытается её создать.

К чему это приводит? Представим себе красивый и нарядный автомобиль BMW: он понятен
как автомобиль — вот его колёса, вот его стёкла, вот он может ехать, его очень легко
представить.

Но представьте: нам надо расписать, как мы будем его создавать, — то есть пошагово описать,
даже при наличии очень чёткого и понятного образа, весь процесс создания.

С чего мы начнём? С шин? Для них нужна резина, размеры? А может, со стёкол? Но стёкла
нужны для дверей — может, начнём с дверей? А двери же под кузов — может, с кузова?

Что я хочу показать: сложная система не просто не понимаема внутри — она ещё и при наличии
семпла этой системы непонятна в рамках процесса создания.

Причём здесь можно также посмотреть на оптимизм инженера, который, например, говорит:
«Ну так я начну строить BMW, начиная с тележки, и потом эту тележку буду улучшать, улучшать —
и получится BMW». Очевидно, на этом этапе мне кажется, что не получится.

Как же в итоге получилась BMW в том виде, что она есть? Эволюция и прототипы,
тестирования и фокус‑группы — это буквально система, которая приняла на себя сложность и
заморозила её в себе, сохранив там труд тысячи инженеров и сотен тысяч часов.

Эту сложность не видно — она канула внутрь системы. И то, что вы видите её как семпл,
не означает, что она вам очевидна как процесс создания, — ведь процесс создания от вас скрыт.

Как и скрыты связи объектов друг с другом. И об этом — следующий пункт.

А если очень хочется скопировать — правильный ответ здесь: планирование от размытого контура
вглубь. О чём я расскажу дальше в главе. Но сначала — о связях.

### 3. Истории с нечёткими линейными связями

В сложных системах некоторые связи не линейны.

Есть прекрасная инженерная сказка: жила‑была девочка, и была у неё замочная скважина
на животе. Девочка думала: «Что это такое, что это такое?» — и вот она задалась целью
узнать.

Взбиралась на горы, плыла через океаны, в конце концов нашла утку; в утке был кролик,
в кролике — яйцо, а там был ключ. Всунула она ключ себе в живот, провернула — и у неё
отвалился… легаси‑код с 10‑летней историей.

На этом достаточно смешном, как мне кажется, кейсе должно возникнуть ощущение того, что
происходит что‑то не то: какая‑то недоработка, может, недостаточно документации,
может, недостаточное планирование — система как‑то не так работает.

Но нет. Проблема в том, что если система работает — это прекрасная система. И её
недочёты — это либо оптимизации, либо допущения инженеров, которые они делают под давлением
внешних обстоятельств (которые также являются частью системы) или по каким‑то внутренним
убеждениям. И то, что вы не видите связи между какими‑то вещами и причины, по которым
это возникает, совершенно не означает, что их там нет.

И это же совершенно не означает, что вы их в принципе должны понимать. Вы можете о них
догадываться, можете экстраполировать их с тем, что понимаете, — но всегда подразумевая,
что есть какие‑то связи, о которых вы просто не знаете.

Попытка же распрямить эти связи приводит к тому, что из двух проблем у вас становится
три — но при этом не факт, что первые две решаются.


### 4. Парадокс неудавшегося планирования

Следующая симптоматика сложных систем достаточно интересна, потому что всегда
находится какой-то инженер, который пытается сделать всё явным, ясным и
понятным.

И вот система в результате начинает обрастать документацией.

Документация, конечно же, явная и понятная, её очень много, тома растут один
за другим, а консистентность становится всё меньше и меньше. При документации в
несколько томов на несколько тысяч страниц её никто, конечно же, уже не читает.

И мы приходим к катарсису: у нас есть проект, который невозможно понять, и
документация, которую можно понять, но она настолько большая, что читать её
никто не хочет. Отчего проще понять, читая проект, так как по объёму он просто
меньше, но понять его тоже невозможно, с чем мы в принципе и начинали.

Но это ладно — это если есть уже готовый проект (в смысле программа, решение
или разработка). А если проекта нет? И документация пишется над абстракциями,
которых даже не существует?

Кажется, какая связь с описательной документацией и с проектной? На самом деле
самая прямая.

Подробная проектная документация, которую пытаются писать по огромному
проекту, которого не существует, — это буквально неработающий и непонятый
никем проект из начала этого пункта. Но только он хуже, потому что это проект,
который не запускается на железе, — который существует исключительно в
фантазиях, где он работает без ошибок, без тестов. И в итоге он скорее ближе по
пониманию к описанному ранее BMW, которое вроде бы само по себе понятно, но
непонятно, как его собирать.

Так как описание окна и описание двери почему-то не приводят к пониманию того,
в каком порядке их собирать, разбирать и изготовлять.

Мораль очень простая: подробное планирование на базе документации для крупных
проектов является такой же утопией, как и попытка осознать их кодовые базы.
Это две стороны одной медали, которые буквально исторически проявляются раз за
разом и, опять же, точно так же раз за разом встречаются с идеалистами,
которые пытаются это исправить.

### 5. Когнитивный параличь и не понимание с чего начинать и где продолжать

А теперь мы переходим к моему любимому симптому, который я на себе не раз
переживал (и, замечу, пережил), и я думаю, каждый его переживал. Это то, как
добиться когнитивного паралича при работе с крупными проектами и как его
добивается каждый, кто в них влезает.

Мне как человеку, любящему алгоритмы (вы, кстати, читали мою книгу про
алгоритмы и структуры данных? Если нет — рекомендую), очень нравится аналогия
с overthinking в этом плане и n! сложностью, которая выражается даже не на
сложных системах, а в принципе на любых, как только мы начинаем слишком
активно просчитывать варианты.

Как-то бедный человек с паттерном overthinking в голове решил планировать свой
поход в магазин за хлебом. Он подумал: если хлеба не будет — возьму печенья.
Поэтому он решил захватить денег с запасом. Но он подумал: а если не будет
работать онлайн-оплата? И решил захватить налички. Но если не будет налички на
сдачу? Он подумал и решил взять наличку на размен. Он посмотрел, сколько стоит
в среднем хлеб в магазинах, и взял даже с запасом, но с другой стороны: а если
магазин не работает? Надо будет пойти в другой. И он посмотрел на карте
города, где расположены магазины. И тут он подумал: а может, взять пряников?
Печенья как-то не очень могут быть. И он стал выбирать пряники. Но теперь всё
планирование испортилось — надо будет вернуться на первый шаг и перепланировать
всё, что было запланировано к этому моменту.

Вот.

Мне кажется, иллюстрация n! в полной красе — вполне понятна. В приведённом
сценарии причём объектов интеракции и абстракций было не так уж и много. А
теперь представьте систему с тысячами объектов, сотнями интеракций и кучей,
кучей, кучей уточнений, причём это всё ещё находится в сыром виде, а где-то
вообще не работает. Уровень когнитивной нагрузки очевидно при этом будет
приводить к просто зависанию и отказу мозга хоть что-то делать.

Ну, сложная система буквально приводит к тому, что человек:
- не понимает, ни что ему делать,
- ни как ему это делать,
- ни зачем он это делает,
- да ещё и прогресса не видит в происходящем,
- и очевидно теряет всякую мотивацию и просто впадает в ступор.

На текущий момент может показаться, что симптоматики для понимания проблемы
вполне достаточно, и вроде бы уже становится понятным, зачем нам нужно
управление хаосом (так как там, где нет системного решения, мы только от хаоса
двигаться и можем, очевидно же — идя в магазин, мы не занимаемся
планированием, а просто выходим из дома и направляемся в сторону магазина,
даже не думая о том, что там будет).

Но всё-таки нам не хватает понимания ещё двух вещей: что такое "мировая
модель" и как она влияет на развитие системы, и что такое "архитектурный рак"
и как его также приходится учитывать при работе со сложными и очень сложными
системами.

Для начала — про мировую модель.

### Влияние мировой модели на развитие системы:

Для начала — откуда взялся термин "мировая модель". Этот термин используют,
когда пытаются объяснить множественные взаимосвязи и влияние множества систем
друг на друга при нахождении этих систем в одном "мире". При этом каждая
система подстраивается под другие, и внутренняя сложность при этом равна
буквально сложности всех таких взаимодействий.

И это очень сильная концепция, которая показывает, что в мире вокруг ничто не
существует просто так само по себе и всегда есть факторы "вне" системы,
которые оказывают влияние "на" систему.

Неучёт же того, что систему окружает, и помещение её принципиально в вакуум
управляемости способно на создание лишь одного — того, что не будет работать
и не будет предназначено для реального мира.

То есть мы не можем просто вырастить систему внутри лаборатории и после этого
утверждать, что с ней будет всё хорошо и в большом мире. Мы вынуждены
тестировать систему на связь с реальностью с самого начала, делая её
реактивной к изменениям, которые на неё накладывает реальность.

Проще говоря, мы не можем сказать: "мы знаем, как система будет работать". Но
мы можем сказать: "мы знаем, как сделать так, что когда система работать не
будет, мы будем вносить в неё изменения".

Это первая часть связи с мировой моделью. И неучёт её очевидно будет приводить
к проблемам и фейлам, которые будут расти в геометрической прогрессии.

Вторая часть — обычно это как раз оперирование "стереотипами". Что такое
стереотип в смыслах мировой модели? Это буквально "выживший" после
взаимодействия со внешней средой, имеющий абстракции и признаки, позволяющие
выживать. И не всегда, а скорее даже всегда не очевидные, замечу. Поэтому
стереотипы имеют непосредственное отношение к хаосу.

Ну так вот, стереотип — это выживший, выживший адаптировавшийся и
представляющий собой модель поведения, которая будет добиваться успеха,
несмотря на то что все взаимодействия вокруг него не будут учитываться.

То есть мы получаем возможность оперирования простой абстракцией. Как пример:
мы можем не знать, как у рыбы работают жабры, но мы знаем, что стереотипично
рыба — это то, что живёт в воде, и, выпустив рыбу в воду, она там скорее
всего выживет.

Возвращаясь ещё и к примеру про BMW, стереотипами там будут являться
компоненты автомобиля, как то: колёса, шасси и так далее. Стереотипично
колёс четыре, руль управления один, а место расположения двигателя спереди.
Почему это будет работать, мы можем не знать, но это БУДЕТ работать, так как
стереотипично.

Аналогично по той же самой причине НЕ будет работать ситуация, когда мы
примемся изобретать собственные велосипеды и решения без связи с реальностью.
Что, собственно, и является итоговой симптоматикой проблемы, которая за этим
возникнет.

Логика здесь очень простая: мысля стереотипами и терминами эволюции, мы
упрощаем восприятие, но при этом гарантируем работоспособность решения.
Мысля терминами "умных" решений и кажущихся оптимизаций — мы сильно
усложняем восприятие, влезаем в зону n! сложности и буквально играем в
лотерею по работоспособности того, что в итоге получаем.

Но это также не всё в плане диагностики проблем. У нас ещё остаётся
"архитектурный системный рак", то есть то, как система в процессе
существования получает негатив, который также влияет на её неопределённость и
хаос, увеличивая их значения и заставляя разработчиков терять контроль.

Переходим к нему.

### Архитектурный системный рак:

Как и было обозначено ранее, система — это не просто что-то, что создаётся
единожды. Это что-то, что живёт и развивается, и это развитие не всегда
заканчивается для системы благоприятно (если не говорить — почти всегда).

Есть ключевые мультипликаторы, из-за которых она, иногда даже достаточно
жутко, деградирует, и которые технически можно купировать, так как они слишком
систематичны и слишком показательны, и на которые надо обращать внимание в
первую очередь.

Их принято называть "архитектурным системным раком". Давайте его разберём.

Вообще, несмотря на достаточно сильное разнообразие последствий, причины
возникновения сводятся буквально к трём:
1. Нерелевантные модули — созданные в процессе упрощения чего-либо.
2. Лишние слои абстракции, созданные либо для поддержки какого-то паттерна,
   либо чтобы "подложить соломки".
3. Нелинейные связи — порождённые свободным взаимодействием объектов друг с
   другом.

Здесь, кстати, надо уточнить: в том или ином виде симптомы болезни будут
находиться в каждой системе. Вопрос в том, до какого уровня они будут доведены
и когда будет потерян общий контроль, в итоге чего они перерастут в гигантский
катализатор сложности.

Бороться же с таким катализатором сложности не так очевидно, как может
показаться на первый взгляд. В случае нерелевантных модулей средство борьбы —
не править, а буквально удалять и переписывать. Так как, как показывает
практика, попытка оптимизировать то, что уже не работает, будет приводить к
тому, что это будет работать чуть лучше, но становиться в рамках когнитивного
восприятия кратно сложнее.

В случае с лишними слоями абстракции с ними можно бороться лишь введением
стереотипов, понятных по тому, как они структурно устроены.

А вот в случае нелинейными связями единственный способ их держать под
контролем — это буквально выписывать эти связи и принципиально размыкать их.

Хотя ещё раз повторю: подобные явления и вызванные ими последствия являются
нормальными. Не увидеть их в кодовых базах в том или ином виде невозможно,
поэтому как-то эмоционально к ним относиться как к чему-то плохому также не
стоит. К ним стоит относиться буквально как к последствиям того, что система
в целом развивается и растёт. А их просто нужно держать под плюс-минус
адекватным контролем.

Иллюзией здесь является то, что если "вот нормально спланировать" и потом
"clean code кодировать" и придерживаться какой угодно любой архитектуры, они
исчезнут целиком.

Нет, не исчезнут. Эта болезнь буквально следует за разработкой по пятам,
создавая и сложность, и хаос, и разработка от них избавиться не сможет.
Проблему нужно просто понимать и принимать.

И раз мы заговорили о принятии и понимании, давайте перейдём к разбору того,
что уже находится в голове самих разработчиков, создаёт им проблему и мешает
жить.

То есть к внутренним психологическим моментам.

## Внутренние психологические моменты разработчика

### Основные концепции относительно восприятия хаоса

Самый настоящий ступор проектов находится именно на человеческом уровне, где
и чаще всего проявляется, а не на уровне технологий и не на уровне
проектирования и планирования.

И выражается этот ступор через последовательное нарушение, опять же всего
лишь трёх основных принципов, это:
+ медленная загрузка контекста в лобную долю
+ глобализация и укрупнение задач и планов
+ привязка к контексту задачи мнения, диктующего её (задачи) исполнение

и основная концепция эмоциональной составляющей работы разработчика.

Давайте же их последовательно и подробно рассмотрим.

### Принцип медленной загрузки контекста в лобную долю:

Первая неочевидная вещь, испортившая жизнь многим разработчикам, — это незнание
того, что информация, или если это называть модным словом контекст,
подгружается в мозг не сразу, а требует достаточно долгого времени. К чему это
приводит, можно видеть на типичном кейсе:

Разработчик берётся работать над задачей, она сложная, он погружён в неё
целиком. Потом у него возникает пауза в один-два дня (а иногда достаточно
просто прошедшей ночи). Задача выгружается мозгом из лобной доли, контекст
теряется, и разработчик буквально не понимает, за что ему браться, испытывая
при этом когнитивный тупик и барьер, который фактически не то что не даёт ему
нормально включиться в работу, но и создаёт эффект прокрастинации и
невозможности начала действия.

Если у вас наблюдается такое — не переживайте, это встречается сплошь и рядом,
и вот, чем сложнее и неопределённее система, тем этот эффект будет
увеличиваться всё больше и больше.

Так же как непонимание этого принципа делает работу для многих невыносимой,
его понимание фактически заставляет думать о задачах в других терминах: не
осознать задачу целиком прежде чем начать, а буквально сесть над ней и начать
её разбирать, вплоть до того чтобы просто рассматривать и делать пометки. И
через какое-то время как раз и будет возникать погружение.

Ну и подобное поведение мозга — вполне, как понимаем, разумно, не может же он
держать вообще всю информацию всегда в быстром доступе, то есть фокусироваться
на чём-то одном.

### Принцип глобализации и укрупнения задач и планов:

Если принцип с медленной подгрузкой контекста скорее свойственен в основном
разработчикам, как я бы сказал, то этот принцип глобализации и наполеоновских
планов на ровном месте известен буквально всем.

Неумение себя сдерживать в планировании системы, действий и задач у
большинства разработчиков приводит к состоянию достижения n! сложности и
просто отсутствия начала работы. То есть работа лежит, плохо делать её не
хочется, как хорошо её сделать так чтобы было глобально и красиво — понимания
нет, в итоге всё просто стоит.

Есть ещё более забавное искажение от этого принципа, когда разработчик
начинает плодить вокруг своего выдуманного и никому не нужного глобального
плана (а он действительно никому не нужен) кучи и горы абстракций.

И в итоге что можно сказать о принципе глобализации: во-первых, он вреден,
во-вторых, он деструктивен, в-третьих — он как раз и показывает, что такое
работа с хаосом и с неопределённостью в чистом виде, так как если вы его
чувствуете и работа стоит, мотивации перейти на методики, представленные
здесь, должна быть уже максимальной.

Ну и у вас должно быть понимание, что глобализация задач, то есть попытка
выстроить всё сразу идеально в реальном мире просто не работает. Смотрите
сами: есть задача про коммивояжёра, где коммивояжёр ищет лучший путь из
возможных на большой карте и в итоге в теории не может его найти, так как
появляется огромное количество возможных комбинаций. Однако на практике — он
просто работает. Работа коммивояжёра не настолько сложна, что для неё
требуются огромные математические расчёты и какое-то гипермегапланирование.

Коммивояжёры ездят в реальности из точки в точку, обмениваются опытом, система
работает просто потому, что воспринимают свою деятельность не как глобальное
решение, а просто как локальные задачи. В разработке всё происходит абсолютно
так же: либо вы глобализуете и стоите на месте, либо вы решаете локальные
вопросы и двигаетесь плюс-минус вперёд по направлению к цели. Да, с ошибками
(которые, кстати, можно исправить), но всё-таки двигаетесь.

Вот и мы двигаемся дальше.
Теперь давайте разовьём историю о контексте.

### Принцип привязки к контексту задачи мнения, диктующего её исполнение:

Очень неочевидный принцип, о чём он.

В вашей голове есть в каждый момент времени определённый контекст, и он
буквально диктует путь решения и определение возможности или невозможности
такого решения.

Неочевидность в том, что:
- Контекст изменится.
- И восприятие изменится.

Таким образом, если у разработчика контекст негативный, он может просто
посчитать, что задача нерешаемая, и бросить её. А если же негативный контекст
будет поддерживаться достаточно долго, то это будет передаваться команде. И
там, где могли бы быть локальные шаги вперёд, будет один огромный пессимизм,
подпитывающий и без того сложную и хаотичную систему, создавая из неё образ
неповоротливого валуна, который настолько плох, что только и может что делать
это создавать всем проблемы и разочарование от того, что даже находишься
рядом (что, как понимаем, неправда, но причина остановки многих стартапов).

Речь здесь идёт фактически о восприятии системы, которое добавляет её
неопределённым частям и возможностям те окраски, которые находятся в
контекстном мышлении разработчика, что с ней работает.

И даже понимание этого позволяет отказаться от субъективного восприятия
происходящего и перейти к объективным действиям.

Логика же здесь работы против этого принципа очень проста: держите головы
чистыми от негативных мыслей и смотрите на вещи объективно, не додумывая и не
давая этим додумываниям выплёскиваться, в том числе, на ваших коллег.

Сложные системы достаточно сложны и страшны и так, не надо им приписывать то,
чего в них нет, и зона непонятности и хаоса в них не должна обрастать
негативными фантазиями, а должна создавать эффект возможностей и манёвра.

Супер, с принципами разобрались, давайте теперь разберёмся с эмоциями.
Так как люди всё-таки не машины, и их эмоции максимально влияют на разработку.

## Эмоциональной составляющей работы разработчика:

Мы уже много чего здесь рассмотрели: и додумки, и негативные мысли, и то,
откуда всё это берётся, и как со сложными системами и неопределённостью
переплетается. Но это было скорее общее видение, а с чем приходится работать
каждому отдельно взятому разработчику — это уже с эмоциями. То есть с тем, что
у него есть здесь и сейчас, и тем, что часто реально и портит ему рабочий
настрой, не давая системе состояться и завершиться.

Итак, эмоции:

Во-первых, эмоции — это крайне оптимизированная реакция на события вокруг,
реакция, не требующая какого-то обдумывания: что-то происходит — появляется
реакция, что-то ещё происходит — другая реакция, быстро и просто, и с точки
зрения мозга крайне энергоэффективно и выгодно.

Кажется по описанию, что это порочный круг, но это не так. Просто, понимая
природу эмоций, мы сразу понимаем, что первое, что нужно сделать для того,
чтобы из этого порочного круга вырваться, — это буквально думать там, где
эмоции имеют место быть. То есть, видя, что реакция эмоциональная,
останавливаться и начинать думать, как бы это сложно и не казалось сначала (а
это сложно).

Но давайте добавим больше конкретики.

Первое, с чего всё начинается, — это импульсивное сомнение в себе и идея о
том, что просто ничего не выйдет, всё завалится, ничего не получится и так
далее.

На самом деле тут не столь опасна эта эмоция, как нативная попытка борьбы с
ней — сказать себе, что у тебя всё получится и всё будет хорошо. Нет. Если вы
не будете использовать корректную методику — всё будет очень плохо, и
настолько плохо, что может даже закончиться депрессией.

А вот если будет понимание того, что является врагом и как против него
работать, всё будет как раз очень хорошо вне зависимости от эмоций, которые
эти события окружают. И вот это крайне важно запомнить.

Далее у нас идёт полностью противоположная эмоция — суперуверенность в своих
силах, базирующаяся на локальной эмоциональной накрутке, которая обычно как
раз и перерастает в эмоцию, описанную сначала. Мы начинаем пробовать, ничего
не выходит, и нам кажется, что всё полный конец и ничего не выйдет.

Здесь важно понимание того, что, как и в первом случае, это просто две стороны
одной медали, и по факту, если вы знаете, как с системой работать и какой
подход использовать, вам от этих эмоций нужно просто абстрагироваться и
начинать действовать, не выдумывая, а думая о реальных вещах.

Отсюда же и рождается общее правило управления эмоциями. Как только вы
чувствуете, что эмоции пошли в разнос, прежде чем реагировать, отвечаем для
себя на два вопроса:

1. Что реально происходит — то есть стараемся описать ситуацию в том виде, как
   мы её видим, стараясь максимально абстрагироваться от эмоциональной
   составляющей и взглянуть на вещи рационально.
2. Задаём себе вопрос, чего мы реально хотим и отчего нам реально будет лучше,
   и аргументированно на этот вопрос отвечаем.
3. После чего уточняем специально для себя, а можем ли мы выполнить задачу,
   если у нас не будет давления времени и сроков, работая просто медленно. И
   если ответ да — то какие сроки для решения кажутся реальными? Может быть,
   проблема именно в давлении таймера.
4. Проделываем первые три пункта, расширяя их на людей, которые вас окружают,
   так как должно быть понимание, что эмоции имеют свойство передаваться в
   команду, так же как и их устранение.
5. Более того, в случае если тупик вызван взаимодействием с другими людьми в
   команде, обязательно задаём им вопрос, чего они хотят, с учётом первых трёх
   пунктов, для того чтобы видеть реальность, а не выдумки, которые очень любит
   создавать мозг, находясь как раз на эмоциях.

Супер. С психологическими моментами разобрались.
Так что давайте переходить от описания отдельных элементов, составляющих
проблему, к её решению. И давайте рассматривать общие методики и подходы,
которые нам позволят работать и с неопределённостью, и с хаосом, на базе всего
того, что мы уже рассмотрели и поняли.

И я хочу отметить, что у нас сюда не вошли моменты, связанные именно с
эффективностью работы, так как для них у нас будет отдельная глава, так как
там будет достаточно много материала. Сейчас будем разбираться именно с теми
моментами, что мы рассмотрели.

## Основные методики и решения:

### Динамика движения и темп в направлении важнее видения и понимания полной картины

Понимание этой методики, я бы сказал, наверное, самое важное и решает до 60
процентов всех возникающих проблем, связанных с неопределённостью.

Если её описывать кратко, она звучит очень понятно:

    выбери путь и иди по нему
    не хватает информации — всё равно начинай движение — по ходу разберёшься

Почему это работает в отношении сложных и крупных систем? Всё просто —
неопределённость и хаос. По-другому с ними просто нельзя. Когда система не
может быть просчитана в принципе, разницы, в каком виде и в какое время ты
начнёшь движение, просто нет. И единственное, что здесь спасает, — это
эвристика, то есть буквально выбор направления движения и коррекция после
совершаемых действий на него.

По сути мы оперируем очень простой и эффективной формулой:

    направление + ошибки = путь

И почему ошибки здесь так важны? Потому что, не понимая плана, мы их физически
избегать не можем, они нам буквально нужны для того, чтобы корректироваться по
отношению к нашей цели. Ошибки — это именно то, что показывает путь в крупных
системах. Не будет ошибок — мы будем лишены наших "глаз", так как из-за
сложности мы буквально не будем понимать, куда мы движемся.

Отчего и практика замалчивания ошибок всегда будет приводить к максимально
плачевным последствиям, что опять же совершенно не так работает, как на
маленьких и локальных системах, которые легко просчитываются и обзорно
управляются от начала до конца.

Но это не всё, формулу можно развить, добавив в неё принцип "два шага вперёд и
один назад". Что это значит? Это значит, что в случае, если мы явно получили
негативный фидбек от реальности (то есть столкнулись с ошибкой), попытка
прорваться вперёд может быть ошибочной. И может случиться такая ситуация, что
нам придётся ещё и откатиться на шаг назад и выбрать вообще другой путь,
потеряв таким образом "прогресс". Так как этот "прогресс" в итоге может
оказаться мультипликатором регресса, причём достаточно сильным.

И в сложных и комплексных системах это именно так и работает. Мы не просто
учимся совершать ошибки и не боимся этого, так как по сути это для нас
единственный способ строить эвристику, но ещё и не боимся откатывать прогресс
для того, чтобы корректировать наш путь.

Проще говоря, на каждой конкретной точке спрашивать себя:
- Как мы сюда вообще умудрились прийти?
- А нет ли решения попроще?
- Мы точно не делаем чего-то, что нашу позицию усугубляет?
- Мы точно идём по направлению к цели?

И первое, и второе порождает ситуацию, когда нам выгоднее двигаться меньшим
темпом и более короткими шагами, что как раз я и передал в тактическом аджайле
в прошлой главе.

Если же мы не будем этого делать, не будем опираться на ошибки и не будем
перестраивать маршрут в мире из хаоса и неопределённости, мы будем получать
то, что называется "туннельное зрение", когда мы видим одну точку, она
абсолютно может быть неадекватной и потерявшей всякую адекватность, но мы всё
равно будем подгонять все наши метрики под её достижение, загоняя и себя, и
проект в глубокую депрессию.

Но вернёмся к ошибкам. Что такое ошибка? Ошибка — это техническое отклонение
от движения к цели. То есть это оценка того, ведёт ли нас действие в сторону
цели или уводит от неё.

Чтобы такую ошибку зафиксировать, нужен прогресс. А на задачах, которые будут
длиться месяцами, его будет просто не видно. Поэтому так важно и иметь бэклог,
поэтому так важно и иметь стадии работы, которые заканчиваются окончательностью
и финализацией. Потому что именно на них мы можем наконец-то наши ошибки
получить.

И всё вокруг вдруг становится очень простым и понятным, и работа становится
безстрессовой, и ощущение движения становится адекватным. Так как именно
потеря ощущения движения и отличает то, почему только взявшись за проект, была
мотивация, а потом она просто пропала.

### Стереотипичное мышление как способ быстрого упорядочивания хаоса:

Силу стереотипного мышления мы уже продемонстрировали ранее, здесь же повторим
эту идею:

Отказ от абстракций и красоты в пользу стереотипичного мышления и надежды на
то, что стереотипы тебя выведут на нужный трек, — просто потому что эти
инструменты эволюционно всегда выводили на нужный трек всегда выше, чем любой
другой подход в условиях неопределённости.

Это работает элементарно:
- меч — рубит
- нож — режет
- компоненты в игровом движке — расширяют функциональность объектов, даря им
  трейты
- а репозиторий в дата-слое микросервисов — хранит запросы, делает их
  управляемыми

Это буквально принцип художника, рисующего глаз человека: при идеальной
технике душа в нём появляется сама, просто если соблюдается стереотип того,
как должен выглядеть глаз.

Причём стереотипы здесь — не ограничение, они буквально попытка
систематизировать что-то на ландшафте неопределённости. Потому что никто не
запрещает создать новый стереотип, оттестировать его (но изолированно) и, если
он покажет себя эффективным, на базе него производить уже другие объекты.

### Движение по контуру выбирая очевидные задачи

Этот принцип развивает теорию понятных и непонятных задач и буквально говорит
следующее: в случае, если система непонятна, развивается нелинейно и окружена
хаосом, всё равно как минимум несколько вещей будут очевидными, как и задачи,
которые нужно сделать.

Таким образом, мы не стараемся управлять системой как огромным проектом, а
стараемся, двигаясь по контуру системы, выделять основные понятные задачи,
которые систему заставляют лучше работать и взаимодействовать с реальностью.
Таким образом, сложность системы делая не препятствием, а частью решения.

То есть, чем система сложнее при таком подходе, тем больше очевидных точек
соприкосновения с реальностью и тем больше очевидных проблем и задач для
решения. Управление проблемой становится проще, так как всегда понятно, что
нужно делать, да ещё и из чего выбирать и приоритизировать под цели проекта.

И да, действительно, это звучит контрэинтуитивно, но это именно то, что и
передаёт идею этой главы: движение в хаосе требует навыков движения именно в
хаосе, а правила для небольших систем для больших систем не подходят.

### Тактика доработок

И указанное выше как раз и порождает текущую тактику — тактику доработок. Мы
знаем, куда мы движемся, мы видим отклонения и можем их корректировать. Мы
понимаем, как нам искать задачи, двигаясь по контуру системы, остаётся сделать
лишь саму работу.

То есть выполнить отдельно взятую доработку на базе тех материалов, что у нас
есть, теми ресурсами, что у нас есть, и не стараясь глобализовать — то есть
сосредоточившись на локальном улучшении системы — то есть на её доработке.

Не планировать при этом эти действия с привязкой к глобальному решению дальше,
чем на уровне направления. Проще говоря, смириться с тем, что если картина
слишком огромна, не пытаться увидеть её целиком, но жёстко сосредоточившись на
видимой её области. И туда уже ввести жёсткое планирование, так как по сути
локальная область и станет тем самым микро-проектом, к которому уже будут
применены обычные правила планирования и постановки задач.

### Структура доминирует над наполнением (развитие стереотипизирования на верхнем уровне)

Мы уже поднимали эту методику, когда смотрели кейс с проектированием BMW, здесь
мы его разовьём.

В чём заключается суть? Можно ли эволюционным путём развить тележку до
автомобиля? Ответ в софт-инжиниринге многих, я думаю, удивит, но он будет
буквально — нет.

Дело в том, что структура очень часто является основополагающей частью
решения, задающей именно то, чем система является. А у тележки и BMW она
просто разная. Физически.

Поэтому эволюция тележки может быть приведёт к эволюции в танк, может быть к
эволюции в трактор, может быть к эволюции в две тележки, но шанс того, что она
закончится именно на автомобиле, является не то чтобы мизерной, а буквально
статистически недостижимой.

И вот поэтому структура и играет такую важную роль в том, ЧТО мы пытаемся
создать, особенно в случае, когда мы пытаемся это скопировать, как в примере
свыше, где структура уже начинает буквально над решением доминировать.

Почему это работает архитектурно:
- Если задать решение в терминах "менеджер решает проблему клиента"
- У нас есть "менеджер по решению проблем клиента"
- Это даёт абстракцию и структуру — наполнение же рождается самой структурой

Построение пустой структуры работает и как мост из точки А в точку Б, и как
построение требований к тестам — которые и так понятны как часть решения.

И структура задаёт возможность соблюдения эвристики, так как часть сложности
системы закладывается в неё именно структурой, то есть разметкой того, где и
что фундаментально будет из максимально очевидных вещей и абстракций.
Вернувшись к примеру с автомобилем: нам может быть непонятна абстракция
"двигатель", что в него включается, почему это работает, но мы точно знаем,
что это именно двигатель и он приводит автомобиль в движение. А это как
минимум развязывает нам руки с тем, как планировать наполнение и куда его
размещать.

Таким образом, хаос и неопределённость структура достаточно сильно нивелирует,
снижая его общий градус сложности в разработке. Какой бы плохой при этом
структура ни была, так как в любом случае какие-то очевидные вещи она в себя
вберёт.

Второй аспект здесь — это то, что структура задаст чёткие линии разреза
компонентов системы друг от друга. Таким образом, нам сразу будет понятно, где
отрезать в системе в случае её эволюционирования.

### Исследовние важная часть наполнения структуры

Переходим к следующей методике. Это размещение исследований (рисеч) в
структуре решения.

Как уже было неоднократно описано выше, нам для начала движения по сути
требуется: направление, задаваемое в условиях неопределённости эвристикой, и
локальный план, по которому мы будем двигаться.

Ну так вот, для того чтобы локальный план стал оптимальным, надо, прежде чем
начать реализацию, провести хотя бы минимальное научное исследование и
посмотреть, к чему наши выдуманные решения могут потенциально привести.

И вот это вот исследование — то есть буквально забегание вперёд на один (а
иногда и несколько, если они являются понятными) шага, по сути исследование и
решает. Потому что часто исследование чётко показывает, что делать не надо, и
на какие проблемы мы в итоге в процессе реализации напоремся, а также показывает
семплы и примеры реализаций, которыми мы в том числе будем оперировать.

Но возникает вопрос объёма исследования (так как всё-таки исследование — это
отдельный вид работ, и на него надо планировать время и ресурсы). И вот тут
ка раз и приходит на помощь структура, так как именно она рисеч и ограничивает.

По сути, что мы в итоге получаем, — структуру, которая следует конечному
решению, в которой будет появляться код, согласно проведённому исследованию, а
также планам и задачам.

Проще говоря, если мы идём программировать веб-сокеты для высоконагруженного
сервиса, нам как минимум надо понимать, что, возможно, нам придётся их
программировать, оперируя не слоем абстракции Spring, а напрямую используя
инструменты веб-сервера Netty. Но мы можем этого не знать — если не проведём
исследование и не найдём информацию об этом, после чего не разместим её в
проекте, привязав к структуре. И когда разработчик будет решение
программировать без данных исследования, ему придётся самостоятельно
выискивать материалы — отчего проект от фазы планирования до реализации станет
неконсистентным.

Обратное же поведение ситуацию исправит. Поэтому приведённая методика и
возникает.

### Законченность на всех уровнях:

Уже много раз я говорил о законченности на всех уровнях, а здесь давайте
подведём этому итог.

При работе с хаосом и неопределённостью, если хочется, чтобы сложность
системы переносилась внутрь, требуется завершённость отдельно взятых её частей
для того, чтобы они воспринимались как операционные блоки, а не как что-то
незавершённое и непонятное.

Проще говоря, если у нас есть законченная абстракция "стул" и "стол", которыми
можно пользоваться, даже несмотря на то, что они плохие, кривые и с кучей
недостатков, это делает возможным от этого наличия планировать и строить
работу. Так как понятно, ЧТО у нас есть, и понятно, КАК с этим быть. А вот
если у нас есть незаконченная абстракция "кухонный гарнитур", которая идеальна
в планах, но при этом комплексная и ещё даже не разработана до конца, — это
создаёт скорее проблемы, чем решения, так как заставляет постоянно к себе
возвращаться. И там, где "плохой стул" можно поменять на "чуть менее плохой
стул", старый просто удалив, сложная абстракция требует точечных правок,
понимания своей структуры и много чего ещё.

Второй аспект в законченности — это буквально психология разработчиков. Нет
ничего хуже инженера, который не понимает, что он делает, почему и с помощью
каких-то инструментов. Это буквально фрустрация на пустом месте и механика её
создания.

Поэтому, если мы хотим команду "счастливых и замотивированных" (и в том числе
вас самих к таким относящихся), вам надо принципиально законченность в работе
как фактор вносить на всех уровнях. Так как именно это и является источником
дофамина для вашего мозга. И это скорее даже важнее для разработки как
процесса, чем системные факторы.

### Разделение мышления на уровнях восприятия системы целиком и локальных планов:

Принципиальное разделение подхода решения задач на глобальном (уровне
системы) и локальном (уровне планирования этапа работ) даёт возможность
относиться к хаосу и неопределённости как к собственно хаосу и
неопределённости, не пытаться в них предвносить методики, которые работают
для небольших систем.

А вот чёткое планирование принципиально оставлять для моментов, когда уже есть
и чётко то, из чего мы планируем, кем мы эту работу выполняем и чего мы точно
ждём.

Любая попытка это отношение смешивать, как понимаем, к добру не приводит. Так
мы много говорили о том, что нельзя переносить чёткие правила планирования на
уровень системы, но дело в том, что если мы начинаем относиться к локальному
спринту также хаотично, как к большой системе, мы перестаём понимать, что мы
в итоге будем получать, и каждый в итоге занимается тем, чем хочет. Таким
образом, мы точно так же создаём фрустрацию и неопределённость, но уже там,
где их можно точно избежать.

### Работа с чужими решениями (как не только учиться, но и перенимать "ошибки"):

Методика работы с чужими решениями — это часть стратегии эффективности, о
которой мы поговорим подробно в следующей главе. Здесь же упомянем лишь то,
что, принимая чужое решение, мы буквально принимаем стереотип в систему. Он
может быть плохим, недостаточно гибким, требующим доработки, но это уже
что-то, на что можно опираться. И с большой долей вероятности это что-то несёт
в себе ещё и значительную внутреннюю сложность, которую мы избегаем и не
переносим к себе в проект в виде фрустрации от необходимости хранения в
головах себя и своих инженеров.

Для того чтобы это увидеть более объёмно, вы должны вспомнить, когда вы видели
исходный код какого-то проекта и вдруг он вас пугал своей комплексностью,
непонятностью и сложностью, хотя вам казалось изначально, что проблема не
такая уж и сложная. Вот этот вот момент "испуга" по сути и передаёт эффект от
того, что внутреннюю сложность реального, а не оптимистично вами выдуманного в
своей голове, видеть и осознавать.

Поэтому при варианте делать своё или брать чужое всегда выбирайте брать чужое,
только если вы не делаете сами что-то локальное и нишевое.

### Практический рабочий флоу:

И давайте подведём итоги и посмотрим на рабочий флоу при работе со сложными
системами, прежде чем перейдём к выводам и ключевым замечаниям.

1) Мы принципиально восстанавливаем контекст у себя в голове относительно того,
   с чем нам предстоит работать, тратя время, чтобы этот контекст получить и
   снять фрустрацию.
2) Двигаемся по контуру системы и выделяем то, что нам понятно и можно
   преобразовать в улучшение.
3) Проводим рисеч — если он требуется.
4) Сверяемся с выбранным направлением и отмечаем для себя: не сошли ли мы с
   пути и не придётся ли нам откатываться, а если придётся — не сожалеем и
   планируем такой откат.
5) Выбираем для себя стереотипы и абстракции, которыми будем оперировать и
   которые нам на сто процентов понятны, в том числе чужие системы.
6) Делаем тесты, которые передают понятность того, что мы хотим, в понятность
   кода, который мы будем в итоге тестировать, таким образом фиксируя локально
   то, что называется ошибкой.
7) И наконец делаем реализацию в ограниченный конечный результат и конечные
   сроки, после чего празднуем очередную завершённость.

И на этом этапе можно говорить, что мы хаос, нет-нет, ни в коем случае не
победили, но научились с ним и неопределённостью работать.

### Выводы и ключевые замечания:

Давайте теперь на фоне всего описанного сведём основные идеи в краткий
перечень того, что нужно запомнить и с чем вам придётся жить дальше до конца
вашей жизни:

Избежать хаоса не выйдет — вы должны научиться жить с ним рядом.
Чем больше ты готов принять хаос, тем выше твоя дисциплина, что может казаться
странным, но это естественно.

Хаос — естественная часть мира вокруг — не надо его побеждать, с ним нужно
учиться работать.

Понять хаос не выйдет — на то он и хаос — вы должны научиться жить с
неопределённостью.

Хаос — ваш друг, а не враг — он даёт вам энергию и возможности, а не забирает
их, поэтому цените и любите его.

При этом, —
Хаос диктует интересные правила — например, о том, что можно решать задачи
без решения, более того, упирается в этом утверждении ещё и в линейную алгебру
и теорию разработки LLM-систем.

И хаос говорит о том, что лишь жизнь в моменте с тем, что у тебя есть прямо
сейчас, и даёт реальный контроль над любой ситуацией, и вот его терять ни в
коем случае нельзя.

На этом мы с хаосом заканчиваем.

Мне кажется, мы его уже достаточно обуздали, чтобы иметь возможность создавать
что захотим, когда захотим и в каком виде захотим, и переходим к
эффективности.

Так как нам хочется, чтобы то, что мы создаём, в итоге всё-таки когда-нибудь
было создано и превратилось во что-то рабочее, а не в бесконечный цирк с
конями (хотя если вы проектируете именно "цирк с конями", возможно, это именно
тот путь, которым стоит пойти).

И главное, не перепутайте общие принципы работы с хаосом с тем, что называют
Chaos Engineering (с использованием Gremlin, Chaos Monkey), о чём мы также
поговорим в этой книге, так как это совершенно разные вещи.

Продолжаем.
