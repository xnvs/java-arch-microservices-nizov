[оглавление](README.md)

# Вводный раздел

# Выбранные принципы разработки

Как уже обсуждалось во введении, чтобы разработка была консистентной (а вы
помните — мы собираем в процессе рассмотрения книги сквозной проект) и как минимум
успешной (а нам, очевидно, хочется, чтобы он был успешным), нам потребуется
чётко следовать минимум трём направляющим — или, проще говоря, нам придётся
выбрать:

1. Принципы разработки.
2. Архитектуру (что с чем группировать, объединять, как и каким образом).
3. Модель авторизации (что в системе будет действовать и как это будут
   идентифицировать).

(Стереотипы и язык с несомой им методологией, как мы понимаем, уже выбраны —
априори задав Java и Spring Framework.)

Нужно сразу понимать: какой бы продвинутый фреймворк или язык программирования ни
был, без рассмотрения этих составляющих мы получим просто технологическую
кашу‑малашу. Поэтому минуть их мы просто не можем и должны обязательно
начать именно с них.

Начнём с принципов — или best practices — с нашей точки зрения. Они станут
основой и базой для написания кода и создаваемых решений.

Мы поделим такие принципы на две части: ту, что относится к архитектуре решения,
и ту, что относится непосредственно к кодированию.

А чтобы это выглядело более интересно, давайте рассматривать это в рамках одной
красивой концепции — так сказать, «культуры разработки».

Когда говорят о культуре разработки, обычно подразумевают разделение на тимлидов,
старших разработчиков, средних, младших, стажёров и так далее.

Мне кажется, это не слишком удачное деление. Чтобы от него уйти и было реально
понятно, кто и чем будет заниматься, введём свои термины:
* Джентльмен или Леди‑разработчик — это человек или ИИ, который будет
  заниматься кодированием.
* Сэр Архитектор — это тот, кто будет заниматься архитектурой.

Давайте напишем для них best practices (принципы работы) и сразу их рассмотрим.

Итак,

## Сэр Архитектор и его принципы работы

Эти принципы будут использоваться, чтобы сделать архитектуру и систему
авторизации. По сути, они представляют собой best practices, принципиально
принимаемые командой на начальном этапе (вы можете их дополнить или изменить под
себя — здесь важно не содержание принципов, а их наличие в принципе).

Итак, принципы:

+ Принцип 1: система собирается из экспериментально проверенных стереотипов.
+ Принцип 2: написанный ARD (Architecture Decision Records) появляется самым первым.
+ Принцип 3: планируем структуру файлов так, чтобы она была максимально структурно плоской.
+ Принцип 4: сервисы группируются вокруг функциональности, а не вокруг сущности.
+ Принцип 5: интеракция между компонентами производится с использованием паттерна «команда».
+ Принцип 6: любой дизайн строится от функциональностей.
+ Принцип 7: нет проблемы — нет решения.
+ Принцип 8: ведение планирования лишь на один конечный шаг вперёд.
+ Принцип 9: дробить абстракции, представляющие данные, на основную и профайл‑части.
+ Принцип 10: отсутствие переизобретения велосипедов.
+ Принцип 11: использует бухгалтерские и юридические термины для описания бизнес‑логики.
+ Принцип 12: не покрытие тестами, а тест как основа разработки.
+ Принцип 13: даём приоритет объектам, не сервисам.
+ Принцип 14: ключи и уникальные идентификаторы объектов отличаются от ключей и
  идентификаторов баз данных.

Ещё раз специально уточню: это принципы, сделанные специально для этой книги,
чтобы перейти на следующие уровни. Они для вас не обязательны, но обязательны для
понимания того, как такие принципы должны выглядеть, чтобы работать и задавать
границы разработки. Без них перейти вниз, спускаясь к архитектуре, будет просто
невозможно — так как не будет ограничений в принятии решений.

Например, принцип «не изобретаем велосипеды» может быть заменён на «ищем
решение нестандартным путём» — для технологического стартапа и т. д. Но здесь я
беру принципы, максимально приближённые к тому, как я вижу разработку сам. А я вижу
её, как понимаете, достаточно консервативно (поэтому и Сэр Архитектор, и
Джентльмен или Леди Разработчик — я хочу, чтобы этот флёр буквально вами
ощущался).

Далее, продолжая эту логику: принцип наличия ARD мы не будем использовать в
книге, так как у нас обоснование появления той или иной технологии — это
буквально наличие главы, где мы должны показать, как она работает. То есть общим
контекстом является буквально книга. Почему мы используем функциональность в
WebFlux? Потому что мы пишем главу про WebFlux.

С этим разобрались. Давайте теперь рассмотрим принципы архитектора подробно.

## Принцип 1: система собирается из экспериментально проверенных стереотипов

Архитектор оперирует в разработке решений лишь стереотипами — то есть
состоявшимися архитектурными решениями, понятными всем окружающим, уже имеющими
запрограммированный архитектурный прототип.

При этом, если для решения нет стереотипа, сначала он создаётся, тестируется
и только после этого передаётся в работу программистам.

Почему это так важно? Программу можно собирать либо как из кубиков и типовых
архитектурных блоков, либо из фантазий и вымыслов, которые нигде, кроме как в
голове архитектора, нормально не сочетаются (максимально искажаясь на уровне
разработчиков).

Наш подход — по сути, организовать конструктор, в котором есть понятные
детали, из которых и будет вестись сборка. То есть сначала делаем и тестируем
детали, потом их размножаем и применяем в решении, а не придумываем каждый раз
что‑то, что будет работать.

Отсюда же следует и устранение непонятных и абстрактных терминов. Например, что
такое Spring Data Rest — понятно: это конкретная абстракция с конкретным
прототипом. А что такое Anti‑Corruption Layer — уже не понятно, за этим может
стоять что угодно. Вот для того чтобы это «что угодно» за этим не стояло,
архитектор должен стремиться к тому, чтобы был конкретный прототип этого
чего‑то — прежде чем это что‑то использовать.

## Принцип 2: написанный ADR (Architecture Decision Records) появляется самым первым

ADR представляет собой текстовый документ, являющийся объяснением, почему или
зачем то или иное решение принимается.

Документ именно текстовый и при этом максимально короткий — не больше чем на одну
страницу (в случае если текста становится больше, он буквально физически
сокращается до размера одной страницы).

Обычно ADR пишется в формате: статус‑контекст‑решение‑последствия. Однако
эта структура является гибкой. Основное требование к документу — ясность того, зачем
будет использоваться та или иная технология или методология.

Архитектор пишет ADR всегда до момента, когда инструмент или технология будут
опускаться на уровень программистов. Это нужно, чтобы на вопрос «почему?»
всегда существовал внятный ответ, а историю развития проекта в плане решений
можно было бы исторически проследить.

Почему это так важно? Любой крупный проект способен очень быстро превратиться в
одну большую невнятность — с решениями, осуществляющимися одними
разработчиками и кажущимися нелогичными и неправильными другим. Такого быть,
очевидно, не должно. Архив из ADR, собственно, эту проблему и решает.

Второй момент здесь — чёткое указание проблем. Очень частая ошибка — начинать
решать проблемы, которых просто нет. «Давайте использовать WebFlux!» —
«Почему?» — «Потому что он реактивный и не блокирует ресурсы». Какую проблему в
нашем проекте это решает? Сразу становится очевидным происходящее.

Так как отсутствие логично и адекватно сформулированных контекста и последствий
сразу же бросается в глаза.

## Принцип 3: Планируем структуру файлов так, чтобы она была максимально структурно плоской

Код планируется так, что вложенность папок и подпапок выглядит следующим образом:
+ один уровень — отлично;
+ два уровня — терпимо;
+ три уровня — уже плохо, следует пересмотреть.

Почему это важно? Потому что вложенность кодовых элементов порождает метаструктуру,
которая запутывает программу, а разработчикам ещё и приходится её поддерживать. А поскольку
при увеличении вложений пакетов она в определённый момент (и гарантированно) становится
неконсистентной.

Плоская структура механически решает проблемы с дизайном, заставляя думать о логических
разделениях так, чтобы код делился на понятные пакеты. Например, если в системе
слишком много файлов, мы вместо:

    UserDomain
        Dto
            AuthDto
            RegistrationDto
        Exceptions
            DataBase
            Logical
            Business
        Controllers
            Web
            Mobile

можем сделать:

    UserRegistrationDomain
        Dto
        Exceptions
        Controllers

    UserMobileAuthDomain
        Dto
        Exceptions
        Controllers

    UserWebAuthDomain
        Dto
        Exceptions
        Controllers

## Принцип 4: Сервисы группируются вокруг функциональности, а не вокруг сущности

Сервисы планируются так, чтобы передавать отдельные виды функциональностей. При этом
возможна даже ситуация, при которой в одном сервисе будет всего лишь один метод (и это
очень нормальная ситуация).

Почему это важно? Это важно по очень простой причине: имея UserService или UserManager,
мы просто физически не можем понять, что это такое и для чего они нужны — там буквально
может быть что угодно.

Логический абстракт, построенный вокруг сущности, всегда приводит к тому, что он
становится непонятным нечто, накапливающим вокруг себя фантазии того, кто с ним работает.

Более того, в определённый момент это создаёт ситуацию, когда он буквально превращается
в god object — то есть выходит на уровень антипаттерна.

Вместо UserService мы можем ввести UserRegistrationService — и сразу получим понимание
того, что этот сервис делает и для чего он предназначен.

Изначально кажется, что проблема может решаться на уровне рефакторинга, но это не так.
Дело в том, что как только что‑то вроде UserService введено и попало в документацию,
диаграммы, описания и т. д., планировать его или рефакторить будет уже не так просто.

## Принцип 5: Интеракция между компонентами производится с использованием паттерна «команда»

При введении интеракции между компонентами архитектор всегда планирует ввести новую команду —
даже если можно ограничиться простым пробросом ивента или вызовом сервиса.

Почему это важно? Потому что только команда:
+ позволяет чётко идентифицировать поток и направление движения логики;
+ представляет собой конкретный физический объект данных, по которому можно установить,
  что конкретно передаётся для исполнения этой команды;
+ позволяет себя прочитать — то есть чётко установить интенцию действия, которое будет
  совершаться;
+ позволяет организовать вокруг себя исключения и валидацию.

На первый взгляд может показаться, что введение команд везде, где только можно, — это
лишнее программирование (буквально). Но в реальности из‑за того, что команда показывает
интенцию действия, мы можем очень легко наблюдать, что в коде в реальности происходит.

Фактически привычка планировать код через команды, а не через прямые вызовы или просто
ивенты, гарантирует, что код будет становиться чище и читабельней.

## Принцип 6: Любой дизайн строится от функциональностей

Планируя развитие системы, архитектор мыслит в терминах функциональностей — то есть
возможностей что‑то сделать и вернуть какой‑то результат в итоге.

Не в абстракциях вроде «организовать авторизацию» и не в бизнес‑логике вроде
«отчитаться за командировочные», а именно в конкретных функциональностях, задаваемых кодом.

Таким образом бизнес‑логика разбивается на отдельно взятые функциональности, после чего
они одна за другой и реализуются. При этом выдерживается идея реализации так, чтобы
отдельно взятая функциональность была полезной и без глобальной бизнес‑логики, к которой
она может относиться.

Сама функциональность планируется сразу как проверяемая отдельными тестами.

Почему это важно? Важность этого принципа задаётся деглобализацией и направленностью
на увеличение возможностей системы в целом. Если этого не делать, система буквально
будет впадать в паралич от архитектурной перегрузки абстракциями.

Если система будет собираться согласно этому принципу, то на вопрос «как работает
авторизация?» можно будет ответить: «Сейчас работает функциональность RBAC, планируется
JWT с ключами». Без этого принципа мы можем получить ситуацию бесконечно
недоделанного решения в промежуточных состояниях сразу по нескольким функциональным
группам.

Более того, придерживаясь этого принципа, реализованная функциональность сразу несёт
с собой необходимые события, исключения и дополнительные объекты — отчего система
становится достаточно легко прослеживаемой и читаемой.

## Принцип 7: Нет проблемы — нет решения

Планируя решение, сначала спроси себя, есть ли реальная проблема, на которую нужно
тратить время.

Потому что мир вокруг архитектора состоит из вещей, которые можно сделать лучше, быстрее,
чище, привлекательней, интересней и т. д., но эти вещи с огромной долей вероятности
не создают реальной проблемы для разрабатываемой системы.

Архитектор, решая проблемы, решает лишь реальные проблемы:
+ отсутствие рефакторинга кода, который не планируется менять, — это не проблема;
+ несоответствие стилистики кода в легаси‑модуле, который работает, — это не проблема;
+ провал в скорости работы, когда можно просто купить новый сервер, — это также не проблема, и т. д.

А вот отсутствие возможности у пользователя зарегистрироваться на сервисе в один клик —
это проблема.

Почему это важно? Время архитектора и команды ограничено, их задача — двигаться вперёд,
создавая функциональности в системе, а не буксовать. Забор непро приоритетных задач
автоматически гарантирует, что приоритетные просто не будут исполнены.

Поэтому первый вопрос, на который должен ответить архитектор: нет ли у нас реальной
проблемы, которую стоит решать? И не решает ли текущее решение вопрос, который даже
не создаёт реальных трудностей в работе системы?


## Принцип 8: Ведение планирования лишь на один конечный шаг вперёд

Архитектор планирует к работе один шаг вперёд — и этот шаг приводит к тому, что
решение относительно системы делает её полноценно рабочей и функциональной.

Совершенно неочевидный принцип подразумевает, помимо этого, что любые работы,
выходящие за один шаг, принципиально игнорируются — на них не выделяется ни
внимания, ни ресурсов.

Поскольку подразумевается, что забегание в планировании вперёд создаёт
неопределённость, которая будет гарантированно работать против реальности, делая
вперёд идущие планы нерелевантными и лишёнными смысла.

Таким образом, время, которое могло бы быть затрачено на планирование забегания
вперёд, тратится более эффективно — на работы, лежащие в ближайшем достижении.

Почему это важно? Ограничивается управленческий паралич и неопределённость,
гарантированно возникающие при забегании в абстракцию. Выполняются и
приоритизируются задачи, имеющие реальный эффект на систему и способные быть реально
осязаемыми.

Неочевидный элемент здесь в том, что, помимо устранения забегания, текущее
решение делается полностью полноценным в рамках того, что делается. Система
работоспособна и функциональна в любой момент времени разработки.

Это влечёт в том числе и то, что может оказаться излишним и будет заменяться в
дальнейшем — но это сознательная жертва в пользу ухода от абстракций.

Отличный пример данного принципа — планирование разработки десктоп‑приложения, в
котором на начальном этапе есть функциональность «открытие/закрытие окна»:
приложение открывает окно, приложение закрывает окно. Если есть функциональность
«приложение работает в fullscreen», она просто игнорируется на всех уровнях
архитектуры — так, как будто её и нет. Промежуточным результатом как раз и
является приложение, выполняющее только открытие и закрытие окна.

Почему так? Дело в том, что функциональность «работает в fullscreen» может к
моменту реализации стать ненужной — по принципу «нет проблемы — нет решения» — и
будет просто обойдена. Но если начинать включать абстракции в тот момент, когда её
ещё нет, это повлияет на всю систему — и повлияет максимально негативным образом.

Антипаттерном при реализации данного принципа является идея «подстелить соломки»:
разработчик пытается планировать на будущее, задавая лишние слои абстракции, не
понимая, что требования могут измениться, а эти слои станут артефактом. Их мало
того что придётся поддерживать — они ещё и добавят лишней жёсткости.

Как же бороться с архитектурной слепотой? Решение приходит из неожиданного места:
подразумевается, что выбор методики разработки, архитектуры и стереотипов
автоматически решит эту проблему.

Так, вводя стереотип «репозиторий», автор кода автоматически решит вопрос
масштабирования запросов — не залезая в решение этого вопроса архитектурно и не
забегая вперёд в планировании. Аналогично — с введением стереотипа «маппер»,
«маршализатор» и так далее.

## Принцип 9: Дробить абстракции, представляющие данные, на основную и профайл‑части

Архитектор, применяя этот принцип, принципиально планирует данные системы так, чтобы
они не содержали внутри себя признаки, относящиеся к разным областям применения.
Например, вводя абстракцию User и задавая там поле «номер телефона для связи»,
автор такого кода физически ограничивает рост данной абстракции. Ведь при появлении
необходимости связываться по мессенджеру, факсу или лично — куда должна
попадать эта информация? Туда же?

Смысл применения принципа в том, что появляется User, в котором, кроме уникального
идентификатора и данных логина, ничего нет. Он переименовывается в UserAuth, а
данные по контактам попадают в UserContact. Таким образом абстракция растёт не одним
объектом, а группой связанных.

Дальше появляются: UserPhotos, UserDirectContact и так далее.

Почему так? Это базовый принцип, позволяющий системе нормально горизонтально расти,
не забегая вперёд в планировании. То есть, несмотря на применение принципа
архитектурной слепоты и ограничение планирования одним шагом, система всё равно
будет нормально расти — поскольку этот рост закладывается ей на уровне принципов.

## Принцип 10: Отсутствие переизобретения велосипедов

При наличии возможности реализовать какой‑то элемент чужими силами — взять решение
со стороны — или реализовать это силами команды, архитектор всегда делает выбор в
пользу «взять решение со стороны».

Речь здесь не идёт о небольших решениях, а о максимально развитых — ведь в них
вложены сотни и тысячи рабочих часов, а также содержащаяся внутри вложенная
сложность, неочевидные проблемы и ошибки.

Почему это важно? На начальном этапе, решая проблему «неудобности»,
«небыстрости» и «недостаточности», архитектор обрекает команду на поддержку кода,
который можно было бы в дальнейшем просто заимствовать. Так команда получает
бесплатное масштабирование.

Отказ от собственной реализации в пользу поддержки чужого решения всегда себя
оправдывает даже в среднесрочной перспективе. А «неудобности» и «небыстрость»
имеют свойство появляться и в локальном решении — точно так же, как они имеются в
стороннем.

## Принцип 11: Использует бухгалтерские и юридические термины для описания бизнес‑логики

Архитектор всегда приближен в своём мышлении к терминам и абстракциям,
используемым бухгалтерами и юристами. Именно это обеспечивает консистентность и
тестируемость бизнес‑логики и её адекватное масштабирование.

Это может звучать странно на этапе разработки, но попытки изобретать
бизнес‑абстракции выглядят не менее странно и концептуально игнорируют тысячелетний
опыт человечества в полировке таких абстракций — на уровне контрактов и
бухгалтерского учёта.

Попытка изобретать бухгалтерский учёт — всегда фейл. Нет ни одного примера, где бы
это увенчалось успехом. А попытки ввести простоту на начальном этапе приводят к
тому, что система раз за разом заходит в архитектурный тупик, становясь при этом
«очень странной».

Почему это важно? Принцип точно такой же, как и со стереотипами: бухгалтерские и
юридические абстракции несут на себе роль именно устоявшихся стереотипов, защищая
систему от ухода от реальности.

## Принцип 12: Не покрытие тестами, а тест как основа разработки

Архитектор изначально строит систему так, чтобы бизнес‑сценарий основывался на
тестах, передающих функциональности, которые затем найдут отображение в коде — но
не наоборот.

Тест должен быть понятен сразу — на уровне бизнес‑логики и сценария (представляя
собой поведенческий тест) и на уровне реализации в абстракциях и стереотипах,
неся с собой то, что называется test‑driven development: сначала пишется тест, а
затем готовится реализация.

Почему это важно? Неочевидная важность данного принципа в том, что при ведении
разработки от тестов обеспечивается её историчность и консистентность как процесса.
Таким образом систему всегда можно проследить от уровня тестов — ведь тесты
показывают, что подразумевалось, когда та или иная функциональность
планировалась и реализовывалась.

Тесты становятся точками входа в логику программы — отчего система становится крайне
понятной и управляемой.

Более того, тесты начинают перекликаться с моделью авторизации и архитектурой,
становясь их логической передачей. Становятся очевидными сценарии, которые могут
возникать, и их edge‑кейсы.

## Принцип 13: Даём приоритет объектам, не сервисам

Архитектор на этапе планирования системы задумывает её в виде разомкнутых объектов,
способных тестироваться отдельно.

Принцип даёт понимание того, что изолированный объект — лучший фундамент для сборки
чего‑то комплексного, чем место, где логика будет перемешиваться.

Например, фильтр авторизации понятен и аудируем, стейт‑машина для логики понятна
и аудируема. А попытка реализовать первое или второе в сервисе гарантирует
сложность тестирования и уход в спагетти‑код — просто по определению.

Почему это важно? Ответ неочевиден: разделяя логику на объекты, сложность
системы переносится из головы разработчика внутрь системы. Система становится сложной,
но читаемой — а разработка из‑за этого — простой и управляемой.

Принцип также максимально важен при разработке абстракций с помощью ИИ. Отдельный
объект — это буквально сам себе контекст: он изолирован и понятен для нейросети. А
спагетти из кода сервисов нейросети не понятен — как и контекст, который обычно
спускается откуда‑то из других мест.

## Принцип 14: Ключи и уникальные идентификаторы объектов отличаются от ключей и идентификаторов баз данных

При добавлении любого объекта в систему ему назначают не только идентификатор для
размещения в базе данных, но и идентификатор, который идентифицирует объект на
уровне системы. Это нужно, чтобы при использовании он позволял вводить в систему
тестовые данные и тестовые сценарии.

Именно второй идентификатор (ключ) и используют для таких сценариев.

Как то:

    UserAuth {
        Integer id;             <- сгенерируется при создании в базе данных для выборок
        UUID    publicKey;      <- идентифицирует объект внутри системы, может быть задан вручную
                                   не используется для выборок, но используется для связей объектов
    }

Почему это важно? Из-за принципиального разделения логики работы баз данных и
логики работы системы как системы, а также из-за возможности воссоздавать любой
из сценариев в тестовой среде.

# Переходим к разработчикам

Отлично, у нас на руках есть принципы относительно архитектуры. Давайте теперь
выведем их на уровень разработчиков — так мы получим полноценную картину того,
как будет вестись разработка.

При этом флоу разработки уже очевидно прослеживается:
1. Планируется функциональность и объекты вокруг неё.
2. Изобретается тест функциональности.
3. Всё замыкается в одном цикле, когда продукт становится полноценным.
4. Работа ведётся на базе оттестированных стереотипов.
5. Затем это спускается вниз — к разработчикам.
6. Там разбивается по отдельным функциональностям согласно уровню разработчика.
7. Прослеживается сверху вниз — как раз через тесты.
8. При этом R&D (тесты стереотипов) и итоговая сборка (на базе стереотипов)
   разделены.

Повторю ещё раз важный поинт: никакой фреймворк не избавит вас от задания
принципов разработки. Одно дело — знать, что в музыке есть семь нот (или
двенадцать, как говорят профессионалы), и слушать музыку, а другое — играть её или,
что ещё сложнее, писать.

А мы переходим на следующий уровень — у нас это Джентльмен или Леди Разработчик.
Наша задача на этом уровне — сделать так, чтобы задачи исполнялись в принципе,
не разваливались, а в системе разработки царила здоровая атмосфера, двигающая
процесс вперёд.

Аналогично уровню принципов работы архитектора, этот уровень нельзя проигнорировать —
нам нужно как минимум понимать, как код будет реализовываться в целом. То есть —
какой в итоге получится программа, когда разработчик сдаст отдельный этап работы.

Про этот тактический уровень можно писать целые книги — что, собственно, и
происходит на рынке. Но мы возьмём лишь принципы, которые связаны с передачей
архитектурных принципов вниз, — чтобы видеть полноценную целостную картину.

Итак:

# Джентльмен или Леди Разработчик и их принципы работы

Вот они — кратко списком:
+ Принцип 1: Стереотипное программирование.
+ Принцип 2: Программирование через сценарии.
+ Принцип 3: Cucumber‑first разработка.
+ Принцип 4: Введение лишь тех объектов, которые напрямую используются прямо сейчас.
+ Принцип 5: Итерационная замена.
+ Принцип 6: Логика как объекты.
+ Принцип 7: Линейность связей объектов.
+ Принцип 8: Хексагональность кодирования.
+ Принцип 9: Кодирование по шагам с промежуточными результатами.
+ Принцип 10: Понимание того, как работает именование.
+ Принцип 11: Контекстное партнёрство с ИИ.

Теперь давайте рассмотрим каждый из них подробно.

## Принцип 1: Стереотипное программирование

Разработчик программирует либо масштабируя, либо прототипируя. На уровне
прототипирования создаются стереотипы и их собственные прототипы, а на уровне
масштабирования они масштабируются, приобретая признаки функциональности.

То, в какой зоне и с какой сложностью стереотипов может работать разработчик, и
определяет его уровень квалификации.

## Принцип 2: Программирование через сценарии

Разработчик пишет реализацию бизнес‑сценариев под ключ — опираясь на тесты,
которые их задают, и на данные, которые их передают. А не просто вписывает код
в произвольные места, как посчитает нужным.

При этом может быть разделение: тот, кто создаёт сценарий (высокий уровень
квалификации), и тот, кто пишет реализацию этого сценария.

## Принцип 3: Cucumber‑first разработка

Принцип вытекает из предыдущего и говорит о том, что код — лишь следствие
сценария тестирования, а не база для появления каких бы то ни было тестов.

## Принцип 4: Введение лишь тех объектов, которые напрямую используются прямо сейчас

Разработчик не создаёт объектов «под запас» или абстракций «под запас». Он
создаёт только те объекты, которые используются напрямую и целиком прямо сейчас.

По сути, принцип развивает принцип одного шага от архитектора, но уже на
тактическом уровне.

Правило распространяется не только на объекты, но и на их поля.

Показательный пример этого принципа — попытка спланировать в объекте User поля
вроде «comment» или «enabled», хотя на этапе программирования они даже не
используются, и непонятно, в какие рамки вообще будут входить.


## Принцип 5: Итерационная замена

Код пишется так, чтобы отдельные объекты можно было вырезать и удалить, а не для того,
чтобы его можно было поддерживать.

Таким образом, на границах объектов выдерживается чистота, а внутри объектов возможно
существование неэффективного хаоса.

Принцип, несмотря на его изначальную контрпродуктивность, вытекает из исторического
наблюдения за разработкой, в которой объект с идеальным кодом может быть просто удалён,
а объекты с буквально очень плохим легаси могут существовать годами.

Принцип это принимает и не старается бороться с реальностью, однако задаёт точку, место
и фокус контроля разработчика — над чёткими границами объектов, что как раз
коррелируется с программированием на базе стереотипов.

## Принцип 6: Логика как объекты

В случае если есть какая‑то логика, она бьётся на такие объекты, как Конфигурация,
Правила и Стейт‑Машины — в любом случае, когда логика становится комплексной.

Принцип опять же дополняет принципы архитектора и нужен для того, чтобы код был
управляемым и адируемым, и, более того, легко модифицируемым силами ИИ.

## Принцип 7: Линейность связей объектов

Разработчик стремится соединять объекты от одного к другому напрямую, для того чтобы
прослеживались линейные связи, идущие лишь в одну сторону, ни в коем случае не
пересекающиеся друг с другом.

Принцип опять же является развитием принципов архитектора и задаёт логическую читаемость
проекта как проекта и его понятность.

## Принцип 8: Хексагональность кодирования

Разработчик поддерживает обмен слоёв и даже просто объектов программы, если это
возможно, через ивенты и команды, никогда — через прямые вызовы.

В итоге на отдельно взятом контроллере или сервисе для взаимодействия с другими
контроллерами или сервисами либо создаются команды, либо принимаются, но никогда не
вызываются отдельные методы отдельных объектов.

Принцип подчёркивает требующийся разрыв между стереотипами и их изолирование как
полностью отдельных сущностей.

## Принцип 9: Кодирование по шагам с промежуточными результатами

При кодировании, которое обязательно ведётся от теста, в отдельно взятом методе
сначала выписываются шаги реализации и только потом заполняются их кодом, при этом шаги
обязательно подписываются в виде комментария. Шаги же при этом связываются друг с
другом через переменные, содержащие промежуточные значения вычислений, которые как раз и
могут передаваться в тестирование.

      public public void workingOnMethodOf(){
          var resultStepOne = resultStepOne();
      }
      private Result resultStepOne(){
          ... работаем здесь
      }

Принцип вытекает из принципа архитектора про тестирование, которое выносится вперёд
кода.

## Принцип 10: Понимание того, как работает именование

Называть объекты системы консистентно и полно, соответствуя их именованию бизнес‑логике
и функциональности, которую они передают, — понимая, как работает именование,
построенное по соотношению того, что называется:

    глагольное,
    контекст,
    объективная относимость,
    прилагательные,
    адвербальные,
    именование интерфейсов.

Таким образом избавляя систему от абстракций вроде UserService, проблемность которых
уже была описана в принципах архитектора.

## Принцип 11: Контекстное партнёрство с ИИ

Выдерживая работу на стереотипах, контекстах и логически корректных именованиях, даёт
возможность выписывать код LLM‑моделям, не стремиться самостоятельно набивать код
как буквы, так как понимает, что это просто неэффективное занятие.


## Микротактические принципы:

Также используются микротактические принципы, которые фактически напрямую определяют кодирование:

Микропринцип: ДТО как слой:

    При соединении объектов соединения осуществляются не через прямые вызовы, а через ДТО,
    которое задаёт представление о том, что поступает на вход и что формируется на выходе,
    в виде отдельного объекта.

Микропринцип: Мапперы как основа преобразований между объектами:

    При преобразовании объектов применяются системные мапперы — ни в коем случае не ручное
    заполнение полей. Логика преобразования объектов — это самостоятельная логика, которая
    принципиально выносится в мапперы.

И на этом всё.

Повторюсь: принципов тактического кодирования настолько много, что можно писать целые
энциклопедические справочники. Но нам это неинтересно — нам важен лишь сквозной уровень,
чтобы с учётом выбранной нами культуры разработки и best practices было понятно, как
кодировать то, что мы определим далее на уровне архитектуры.

Опять же, эти принципы можно изменить. Принципы выше созданы специально для этой книги —
чтобы разработка сквозного проекта в ней была консистентной.

Подразумевается, что разработчик волен программировать как угодно — до тех пор, пока он не
нарушает принципы, заданные на верхнем уровне. Поэтому воспринимайте эти принципы не столько
как ограничение, сколько как задание степеней свободы для отдельного инженера.

Кроме того, мы исходим из того, что кодирование должно быть спокойным и приятным
процессом, а не авралом с криками и тушением пожаров. Именно такие проблемы наши
принципы и решают.

# Держим систему под контролем: принципы контроля

Помимо принципов для архитектора и разработчика, нам потребуются Принципы Контроля — то есть
набор правил, придерживаясь которых, система будет как минимум управляема и аудируема.

Мы понимаем, что архитекторы и разработчики могут меняться, а система останется. Поэтому нам
нужен ещё один уровень — принципы контроля кода (в частности) и системы (в целом).

Контроль во многом перекликается и даже дублирует то, что описано в принципах архитектуры и
разработки. Не удивляйтесь дублям — у них разный контекст.

Кратко наши правила:

+ Правило 1: Отдельные объекты для регулирования (ruling)
+ Правило 2: Конфигурация — это отдельные объекты
+ Правило 3: Стейт‑машины
+ Правило 4: Единая точка ответственности
+ Правило 5: Единая точка истинности
+ Правило 6: Версионирование
+ Правило 7: Холды, лимиты и клиринг как правила взаимодействия распределённых элементов
+ Правило 8: Изолирование функционала в домейнах
+ Правило 9: Каждый объект системы кем‑то владеется
+ Правило 10: Дополнительная короткая авторизация на важных операциях
+ Правило 11: Супервайзинг
+ Правило 12: Двойная запись и согласованность
+ Правило 13: Валидация ДТО на промежуточных передачах
+ Правило 14: Аудиты и метрики, подключённые параллельно, а не напрямую
+ Правило 15: Подбиваемые итоги работы системы на EOD/BOD (End of Day / Beginning of Day)

Теперь рассмотрим их подробно:

## Правило 1: Отдельные объекты для регулирования

В системе действуют логические правила (ruling), которые выносятся отдельно и также отдельно
отслеживаются в системе. Они строятся на архитектурных стереотипах и фактически всегда
являются отдельными объектами — по принципу «одно правило — один объект».

## Правило 2: Конфигурация — это отдельные объекты

Конфигурация подразумевает отдельные объекты. В том числе конфигурацией являются не просто
данные, но и формулы. Код исполняется на базе конфигураций, а не на базе значений, вшитых
в этот код.

## Правило 3: Стейт‑машины

Сложная логика передаётся стейт‑машинами, которые аудируются отдельно с помощью
отдельных тестов.

## Правило 4: Единая точка ответственности

За сложный процесс всегда отвечает один объект (сервис‑менеджер) — целиком. Именно на нём
собирается статистика, и именно относительно него проводятся аудит и тесты.

## Правило 5: Единая точка истинности

Принцип расширяет предыдущий и утверждает, что у любой операции всегда есть единый источник
истинности. Например, если два сервиса параллельно выполняют одну операцию, она должна
сопровождаться объектом, который показывает, как операции сервисов выполняются относительно неё.

Мы не даём каждому сервису что‑то делать с последующей синхронизацией — вместо этого сразу
задаём объект синхронизации в одном месте и позволяем отдельным сервисам выполняться вокруг него.
(Эту логику я дальше покажу в книге на примере логики распределённых транзакций.)

## Правило 6: Версионирование

При удалении объекта из системы он версионируется, а не модифицируется напрямую. Это позволяет
прослеживать в аудите — что было и что стало.

## Правило 7: Холды, лимиты и клиринг как правила взаимодействия распределённых элементов

О содержании я расскажу в книге позже. Здесь отмечу лишь, что если сразу не выбрать принцип
взаимодействия распределённых объектов и не сделать его однотипным, контролировать это
в дальнейшем будет очень тяжело.

+ Холд — резервирование ресурса до проведения операции.
+ Лимит — ограничение на проведение операций в единицу времени и других операций.
+ Клиринг — сверка как отдельное действие между объектами, чтобы все операции были
  корректно разрешены в плане учёта.

## Правило 8: Изолирование функционала в домейнах

Код операций должен быть изолирован в отдельных домейнах — чтобы при аудите было понятно,
где находятся его основные направляющие.

## Правило 9: Каждый объект системы кем‑то владеется

Подразумевается, что у каждого объекта в системе есть владелец, и владелец
выдаёт ключи доступа к объектам, которыми он обладает. Таким образом, всегда
понятно, кто и почему, и на какой момент получил подобный ключ и
воспользовался им для доступа.

## Правило 10: Дополнительная короткая авторизация на важных операциях

Развитие прошлого правила с уточнением: важные операции учитываются отдельно, и
для них требуется прохождение дополнительной авторизации, чтобы быть уверенным, что
она корректна и не сфальсифицирована.

## Правило 11: Супервайзинг

У каждого пользователя в системе, кроме администратора, есть технический супервайзер —
то есть пользователь, способный получить доступ к данным и проверить, что с ними
происходит.

А на сложных операциях, выполняемых пользователем, его супервайзер должен также
давать разрешение.

## Правило 12: Двойная запись и согласованность

Любая операция в системе не возникает просто так, сама собой: она на базе
своего ресурса откуда‑то его берёт и куда‑то его предоставляет.

Учёт движения таковых ресурсов и подразумевается двойной записью, когда мы чётко
видим, откуда и куда ресурс перемещается. Причём это актуально не только для
финансов, а именно двойные записи часто и являются предметом аудита и контроля.

## Правило 13: Валидация ДТО на промежуточных передачах

Подразумевается, что валидация на базе правил и выбросы исключений, которые
логируются при некорректной валидации, являются точкой контроля за корректностью
данных в системе.

## Правило 14: Аудиты и метрики, подключённые параллельно, а не напрямую

Метрики подключаются к системе параллельно, а не напрямую внутрь, таким образом
они являются отдельными от системы, не подвергаются искажениям системы и
объективно показывают то, что в системе происходит.

## Правило 15: Подбиваемые итоги работы системы на EOD/BOD (End of Day / Beginning of Day)

Система подбивает свои итоги на окончание рабочего дня и на начало рабочего дня,
чтобы контролирующим системам было с чем работать.

И на этом всё.

Опять же повторяюсь — правила могут выбираться вами самостоятельно. Я просто
показываю пример для этой книги, чтобы консистентно двигаться в сторону
технологического решения, так как, не понимая ограничений, мы ни архитектуру
создать не сможем, ни адекватно что‑то запрограммировать.

И ещё очень важный аспект: как видите, правил и ограничений на самом деле не так
уж и много — их буквально можно выписать в три небольших списка. При этом каждый
пункт этого списка — это не какая‑то абстракция, а конкретное правило, которое
делает разрабатываемую систему понятной.

Давайте напомним, что у нас получилось, и обратите сразу внимание, что
разработка стала обзорно понятной как процесс:

#### Принципы архитектора:

+ Принцип 1: Система собирается из экспериментально проверенных стереотипов.
+ Принцип 2: Написанный ARD (Architecture Decision Records) появляется самым первым.
+ Принцип 3: Планируем структуру файлов так, чтобы она была максимально структурно плоской.
+ Принцип 4: Сервисы группируются вокруг функциональности, а не вокруг сущности.
+ Принцип 5: Интеракция между компонентами производится с использованием паттерна «команда».
+ Принцип 6: Любой дизайн строится от функциональностей.
+ Принцип 7: Нет проблемы — нет решения.
+ Принцип 8: Ведение планирования лишь на один конечный шаг вперёд.
+ Принцип 9: Дробит абстракции, представляющие данные, на основную и профайл‑части.
+ Принцип 10: Отсутствие переизобретения велосипедов.
+ Принцип 11: Использует бухгалтерские и юридические термины для описания бизнес‑логики.
+ Принцип 12: Не покрытие тестами, а тест как основа разработки.
+ Принцип 13: Даёт приоритет объектам, не сервисам.
+ Принцип 14: Ключи и уникальные идентификаторы объектов отличаются от ключей и идентификаторов баз данных.

#### Принципы разработчика:

+ Принцип 1: Стереотипное программирование.
+ Принцип 2: Программирование через сценарии.
+ Принцип 3: Cucumber‑first разработка.
+ Принцип 4: Введение лишь тех объектов, которые напрямую используются прямо сейчас.
+ Принцип 5: Итерационная замена.
+ Принцип 6: Логика как объекты.
+ Принцип 7: Линейность связей объектов.
+ Принцип 8: Хексагональность кодирования.
+ Принцип 9: Кодирование по шагам с промежуточными результатами.
+ Принцип 10: Понимание того, как работает именование.
+ Принцип 11: Контекстное партнёрство с ИИ.

#### Правила контроля системы:

+ Правило 1: Отдельные объекты для регулирования.
+ Правило 2: Конфигурация — это отдельные объекты.
+ Правило 3: Стейт‑машины.
+ Правило 4: Единая точка ответственности.
+ Правило 5: Единая точка истинности.
+ Правило 6: Версионирование.
+ Правило 7: Холды, лимиты и клиринг как правила взаимодействия распределённых элементов.
+ Правило 8: Изолирование функционала в домейнах.
+ Правило 9: Каждый объект системы кем‑то владеется.
+ Правило 10: Дополнительная короткая авторизация на важных операциях.
+ Правило 11: Супервайзинг.
+ Правило 12: Двойная запись и согласованность.
+ Правило 13: Валидация ДТО на промежуточных передачах.
+ Правило 14: Аудиты и метрики, подключённые параллельно, а не напрямую.
+ Правило 15: Подбиваемые итоги работы системы на EOD/BOD (End of Day / Beginning of Day).

## Итоговые выводы:

Отлично, мы создали принципы, на базе которых теперь сможем сделать архитектуру и
уже сможем перейти к созданию приложений.

Что будет, если этих принципов не будет? Очевидно, у нас будут проблемы с
архитектурой, так как у нас просто не будет границ и ограничений, в рамках которых
она создастся.

Вообще, в целом, как видите, мы движемся максимально линейно и понятно.
Поэтому давайте двигаться в сторону архитектуры.

