[оглавление](README.md)

# Введение

## Что вы получите, прочитав эту книгу, и требования к вам:

Моя основная задача и цель - вывести вас на уровень senior / tech lead. При этом
я подразумеваю, что уровень читателя - это уровень человека, плюс‑минус хорошо
освоившего Java Core. Хотя, если встретится какой‑то «интересный» код, я также
объясню, как Core работает в том числе.

У меня есть чёткое понимание: книгу могут читать, будучи уставшими с работы.
Поэтому стиль изложения будет специально выдержан максимально простым и понятным.

А теперь - самое интересное: что вы в итоге получите, прочитав эту книгу:

1. Вы будете легко ориентироваться в архитектуре.
2. У вас не будет проблем с проектированием и сборкой Java Spring‑приложений
   любой сложности.
3. Вы легко будете ориентироваться в бизнес‑логике и требованиях бизнеса.
4. Будете знать полный стек приложений для работы на любой позиции Java‑разработчика -
   от middle до senior и даже выше.
5. Глубоко разберётесь более чем в 40 видах технологий - не с точки зрения
   энциклопедического перечисления, а с точки зрения практических реализаций.

Звучит амбициозно? Естественно. Иначе я бы за написание этой книги просто не взялся.

## Вторая из серии книг:

Эта книга - часть серии, в которую входят:

1. Алгоритмы и структуры данных.
2. Архитектура и работа с микросервисами на Spring.
3. Математика и статистика.
4. Бухгалтерия, финансы и смарт‑контракты (RWA) для инженеров.
5. Разработка ИИ‑агентов.

Поэтому, если вам не хватает развития именно программирования как алгоритмирования
или работы с нейросетями, ищите эту информацию не здесь. Книги достаточно крупные,
и я посчитал, что лучше их контент не перемешивать.

Ссылки на остальные актуальные версии книг вы можете получить в моём
GitHub‑репозитории.

## Настроение и цель книги (последовательное изложение):

У каждой книги есть настроение. Настроение этой книги - «командная работа». Мне
хочется, чтобы вы чувствовали: вас за руку ведут до результата - так, как если бы
вы были моим коллегой, а моя задача - добиться того, чтобы вы работали эффективно
и качественно.

Этого мы и будем добиваться.

Хочу от себя заметить: книжка получилась довольно большой. Однако это как раз тот
объём, который нужен, чтобы работать на старших инженерных позициях. Поэтому имеем
что имеем.

К сожалению, простую задачу невозможно решить легко - требуются некоторые усилия.
Эта книга как раз такие усилия собой и представляет.

## Что создаёт проблему в изучении архитектуры, микросервисов в целом и Spring в частности (однотипная методология):

То, чего по сути не хватает большинству книг на рынке и что в основном послужило
причиной написания этой, - отсутствие внятного линейного повествования,
позволяющего читающему стать специалистом.

Если абстрагироваться от архитектуры и взять аналогию, это очень похоже на
изучение музыки: куча музыкальных инструментов, куча нот, гамм, аккордов и так
далее, и тому подобное.

Новичек в этом болоте просто вязнет: непонятно, где начало, где конец, что
нужно, а что нет. В этой книге мы этого как раз будем избегать. Мы будем вести
разработку через сквозной пример и по набору чётких границ, которые пойдут от
языка и закончатся best practices в кодировании.

Отчего вам всегда будет на 100 % понятно: что нужно использовать, почему это
нужно использовать и как это будет работать (или не работать). Причём основные
столпы вроде ДДД и хексагоналки мы также рассмотрим.

Но сначала поговорим о границах и о том, с помощью чего мы их организуем. Начнём
с языка программирования.

## Триада языков программирования и положение языка Java:

Почему для написания книги по архитектуре и микросервисам были выбраны именно Java
и Spring? Начнём с языка программирования - и, как ни странно, с синдрома
самозванца.

История про языки программирования и про синдром самозванца связана куда больше,
чем вам может показаться. Если вы держите эту книгу в руках, очевидно, вы -
Java‑разработчик. Но что такое быть разработчиком? Это значит быть
квалифицированным в чём‑то, а квалификация обычно требует инвестиций времени в
себя.

И вам значительно повезло в этом, так как Java - составная часть языков
программирования, которые я называю Триадой: это С++, C# и, собственно,
Java.

Причём Java в этой триаде - по сути базовый язык, с которого надо начинать. Он
имеет одну парадигму и одну, по сути, сложившуюся экосистему для разработки - чего
и первый, и второй язык по сути лишены, так как они слишком разнообразны и в
инструментах, и в подходах к разработке.

Однако, освоив Java, вы можете легко смещаться и в С++, и в C#. Отчего
двигаться в другие стеки, можно мягко сказать, глупо. Так, ваш сдвиг в Rust
или Go ничего как разработчику для вас не даст. А вот ощущение, что вы ничего
не умеете, - даст более чем. И синдром самозванца появится буквально сам собой.

Поэтому моя рекомендация: если вы работаете с Java, сосредоточьтесь на языках
Триады. В С++ вы найдёте высокоскоростные вычисления и машинное обучение, а в
C# - геймдев. Полный спектр того, что можно сделать, у вас под руками.

Смещая же парадигму даже в сторону Kotlin, вы будете буквально терять
собственную квалификацию. Так как невозможно, уча одно, не забывать другое: в
сказочном мире это не так, в реальности - так. Программист Java может
безболезненно перейти на другой язык Триады, программист Kotlin - нет.

Но поинт тут не в самой Триаде, а в том, почему Java всё‑таки была выбрана
для этой книги. Потому что - унификация и понимаемость разработчиками.

Так, только на Java проектах. "А" будет выглядеть как проект "Б" на 90–99 %. И
именно это позволяет, например, эту книгу написать.

## Развитие идеи языка через стереотипизацию, стереотипизация Spring:

Второй крупный аспект - стереотипы.

И здесь нам как раз приходит на помощь Spring: его стереотипы богаты и покрывают
почти весь EE‑ландшафт.

Spring решает грандиозную задачу:

- Мы говорим «репозиторий» - и сразу понимаем, что это.
- Мы говорим «DTO», или «автоконфигурация», или «маппер» - аналогично.

Отсюда же, так же, как и с языками Триады, ваши «попрыгушки» на другие
фреймворки, которые работают быстрее или «проще», по сути, будут давать вам лишь
дисквалификацию как разработчику.

В Spring‑экосистеме вид стереотипов крайне типичен и крайне понятен. Таким
образом, если мы идём от языка через методологию разработки к стереотипам, мы уже
с вами говорим «на одном языке» и можем переходить к следующему элементу пазла,
чтобы стать идеальными разработчиками.

## Выбор принципов разработки, коррелирующихся со Spring (джентльмен или леди‑разработчик):

У нас уже есть на текущий момент:

+ язык;
+ методология разработки;
+ стереотипы фреймворка.

Следующим уровнем будет выработка принципов разработки - то есть общих правил, по
которым ведётся разработка: как написание кода, так и планирование написания кода
в целом.

Мы создадим для этого специальный стандарт, который у нас будет красиво называться
«Принципы и правила для джентльменов и леди‑разработчиков». По сути, они будут
представлять best practices того, как организовывать работу архитектора и отдельно
взятых разработчиков.

Этот стандарт мы также рассмотрим в отдельной главе книги.

Имея в наличии принципы, по которым строится разработка, мы можем сделать на их
базе следующий элемент пазла.

## Учебная архитектура !CAT как набор стереотипов, коррелирующихся со Spring:

Этот элемент пазла - архитектура.

Что такое архитектура в контексте Java? Это буквально то, каким образом мы на базе
стереотипов и принципов разработки будем строить систему, чтобы в итоге получить
нужное решение.

Когда мы говорим «авторизация», мы имеем в виду какой‑то набор стереотипов,
делающих свою работу. Когда говорим «транзакция» или «репликация» - аналогично.

Для этой книги я разработал сквозную учебную архитектуру. Она построена на стереотипах
Spring и методологии разработки на Java - и поможет понять, как будут
использоваться объекты Spring.

Мы разберём её в отдельном разделе. На её основе вы поймёте, как в целом
устроена архитектура приложений.

## Учебная модель авторизации как коррелирующаяся со Spring:

Это ещё не всё - продолжим цепочку.

У нас уже есть:
+ язык;
+ методология разработки;
+ стереотипы фреймворка;
+ принципы разработки;
+ архитектура.

Теперь переходим к действующим лицам внутри этой архитектуры - именно этим обычно
занимается модель авторизации.

Согласитесь, есть разница:
* наши пользователи - администраторы, операторы и простые пользователи;
* наши пользователи - все линейно пользователи, а права подтверждаем выдачей ключей;
* наши пользователи - работники организации, а их уровень доступа задаётся подчинением
  и отношением к департаментам.

Это и называется «модель авторизации». Она формально не относится к архитектуре - это
следующий слой, буквально слой бизнес‑логики. Он подразумевается при разработке
отдельных компонентов системы, их прав и обязанностей относительно друг друга и
взаимодействия.

Один компонент системы может работать на одной модели авторизации, другой - на другой.
Но то, на чём они будут работать, надо выбрать сразу. Иначе мы просто не сможем
контролировать работу системы - происходящее внутри неё будет неочевидным.

Поэтому в книге будет специальная учебная модель авторизации - полная и комплексная.
Разберём её в отдельной главе.

## Работа в рамках двух сценариев: маркетинг и финансы:

Отлично, у нас уже есть:
+ язык;
+ методология разработки;
+ стереотипы фреймворков;
+ принципы разработки;
+ архитектура;
+ модель авторизации.

Теперь нужны эдж‑кейсы, чтобы объяснение было понятным и привязанным к
реальности. В книге для этого используем два направления работы практически любой
компании:

+ маркетинг - где важны объёмы данных и скорость, но не важны ни
  консистентность, ни слишком большая точность;
+ финансы - где весь упор делается как раз на точность.

То есть при разборе кейсов в книге мы будем ориентироваться на эти два департамента -
при реализации наших фич.

## Бухгалтерский модуль и смарт‑контракты как механика разработки:

Чтобы финансовая часть работала корректно, сразу планируем и делаем:
* бухгалтерский модуль;
* модуль смарт‑контрактов.

Так мы не будем изобретать велосипед, обходить тысячи эволюционных шагов и
придумывать, как должны работать деньги.

В книге вы освоите:
* как работает бухгалтерия;
* как работают счета и проводки и всё, что с ними связано;
* как работают контракты, в частности - смарт‑контракты;
* как с их помощью реализуются сложные отношения сторон.

Понимание этих двух блоков даст вам возможность мыслить в коде на языке бизнеса, а
не на уровне человека, который изобретает колесо и радуется своей гениальности.

## Базовая функциональность сквозного проекта (фича на микросервис, банковское приложение):

При наличии всех элементов нам не хватает только сквозного примера для книги - им
станет банковское приложение. В нём отдельные фичи будут реализованы как набор
микросервисов.

Так мы будем создавать технологический зоопарк решений - но с опорой на то, что уже
работает.

Это позволит:
* вам - не теряться на общем фоне;
* мне - придерживаться линейности повествования.

Поскольку работаем на Java, приложение будет банковским - и отлично впишется в
концепцию «финансы+маркетинг». Банки как раз этим большую часть времени и
занимаются.

Фичи сделаем намеренно наивными - чтобы максимально чётко показать технологию, которую
рассматриваем в каждой главе. Не будем расписывать огромный комплаенс, который
нужен в продакшене: всё‑таки это книга по технологиям.

## Работа с кодом на двух уровнях (удобство разработки, тесты и CI/CD):

Очень важный момент, который выдерживаем в книге, - как удобно:
* кодировать;
* тестировать;
* собирать и разворачивать.

Инфраструктура Spring позволяет всё это - но требует отдельного подхода. Это ключевой
момент. Я покажу, как писать программы, чтобы не уставать и не испытывать стресса.

Будем использовать полный комплекс, казалось бы, тяжеловесных инструментов: TDD,
BDD, Cucumber, CI/CD. Моё мнение: они кажутся сложными, потому что их не
понимают. Именно этого понимания и добьёмся в книге.

Сразу привыкнем вести разработку правильно - чтобы потом не расстраиваться из‑за неудач.
У нас всё будет получаться.

## Причина, почему у многих не получается:

Итак, о неудачах.

Причин (проблем), почему многие не осваивают архитектуру и микросервисы, две.

Основная проблема - изначальная разрозненность ландшафта и отсутствие вменяемой
методики преподавания. Она должна показывать не энциклопедичность знаний, а
возможность буквально делать решения - и сразу плюс‑минус правильно.

Эта проблема порождает:
* дикую когнитивную перегрузку;
* сталкивание с разрозненными курсами (вот курс по JPA, вот по сагам, вот по
  деплойменту, вот по безопасности и т. д.).

В итоге сложность растёт в геометрической прогрессии - и следует закономерный фейл.

Вторая проблема - попытка решать сложную вещь просто.

Аналогия: перед вами шахматы, а вы пытаетесь играть в них как в шашки. Да, это
доступно, да, может даже получаться - но это не тот метод.

Проблема порождает создание распределённых монолитов с уродливой авторизацией и
невнятной логикой. Они работают, но их неинтересно ни программировать, ни
сопровождать.


## Причины, почему у вас точно получится:

Причина, почему у вас точно получится, ровно противоположна причинам, по которым у
многих не получается. Мы задаём одно сквозное решение - через все технологии, которые
возможны для встречи с вами, - и линейно разбираем их, прямо до самых минимальных
атомов.

То есть если мы будем разбирать JPA, мы тут же разберём и SQL. Провалов в
информации или разночтений мы просто не допустим.

Мы сразу же будем учиться программировать правильно и корректно. Более того - будем
учиться программировать так, чтобы это было приятно и весело.

Какой смысл делать что‑то, если тебе это делать неприятно?

Фактически я готов дать гарантию: пройдя всю книгу, у вас не будет ни одного вопроса
о том, как работать, в какой последовательности и с использованием каких технологий.

## Структура повествования:

Сначала мы подробно разберёмся с тем, как работает архитектурное планирование и
сборка программ на микросервисах в принципе. После этого у нас будет две главы про
софт‑скиллы, которые нужны разработчику. Всё‑таки программы собираются людьми, и
это нужно делать с умом и разумно - так, чтобы не испытывать ступор и депрессию в
конце (а то и в середине) проекта.

Затем мы последовательно рассмотрим, как мне кажется, 95 % из того, что вы можете
встретить в плане технологий на своём пути, работая со Spring.

Мы будем двигаться по темам, которые я предварительно линейно «распрямил», создав
структуру этой книги и привязав к каждой теме по фиче. На ней как раз можно будет
интересно посмотреть реализацию.

Если какая‑то тема будет забегать вперёд, мы в этот момент остановимся и дадим
общие знания - объясним, как тот или иной элемент работает. Просто в меньшем
объёме и менее подробно, чем это будет сделано в отдельно взятой главе.

## Напутствие и рекомендации:

Книга достаточно крупная по размеру, поэтому наше с вами путешествие будет довольно
долгим. Я хочу пожелать терпения и выдержки: в конце концов всё это окупится и
превратится в ваш опыт и деньги - буквально.

Не торопитесь: одной главы в день вам будет вполне достаточно для чтения. Я специально
подбираю размер глав так, чтобы вы могли, не перегружаясь, разобрать одну из них,
не испытывая какой‑то чрезмерной когнитивной нагрузки.

Ну что, приступаем к разбору вводного раздела.

