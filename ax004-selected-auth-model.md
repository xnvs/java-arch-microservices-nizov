[оглавление](README.md)

# Выбранная модель авторизации

Отлично, у нас уже есть принципы разработки и архитектурная модель, остаётся
лишь создать модель авторизации.

Модель авторизации выбирается отдельно и от архитектуры, и от принципов,
поскольку буквально показывает, каким образом мы на стереотипы архитектуры
будем «надевать» права и возможности ими пользоваться для различных ролей
пользователей.

Более того, из неочевидных вещей здесь и то, что технически модель
авторизации можно вообще откладывать до последних стадий разработки, вводя
внутри системы на начальных этапах лишь одного пользователя — системного
администратора, после чего у него постепенно снимать права.

Позволяет так программировать не каждый язык программирования и не каждый
фреймворк, но как раз Spring этим и отличается: благодаря ему мы можем
«нацеплять» на отдельные точки входа в операции нотации, которые как раз
авторизацией и будут управлять.

Итак, давайте приступим к модели авторизации.

У нас проект учебный, поэтому моделей авторизации будет две:

Первая (1) будет базироваться на принципе введения роли администратора с отдельным
реестром пользователей‑администраторов. То есть мы будем подразумевать, что
если пользователь входит в подобный реестр, то он может выполнять любую
операцию без ограничений.

В этот же реестр у нас также войдут и системные сервисы, каждый из которых
технически будет выполнять операции под именем пользователя (Service Account).
Таким образом, системные пользователи у нас будут внутри системы администраторами,
но при этом не лишены потребности проходить авторизацию.

Эта модель авторизации у нас технически относительно точек функциональности
ничего не будет требовать, однако мы всё равно будем снабжать точки входа
аннотацией:

    @AuthAdminUserCan

Эта аннотация будет показывать, что вне зависимости от установленных правил
доступа функциональная точка входа может быть выполнена, если пользователь, её
исполняющий (в терминах SpringFramework — принципал), имеет право её выполнить
без ограничений.

Сам же доступ у нас будет обеспечиваться по JWT‑ключу, который будет
выдавать микросервис администраторов и будет среднесрочным (будет действовать в
течение одного часа).

Несмотря на кажущуюся простоту, первая модель авторизации отличается
достаточной комплексностью, так как от нас потребуется:
1. Вести реестр администраторов (имя пользователя/пароль).
2. Требовать от системных сервисов при взаимодействии друг с другом иметь права
   администратора, то есть также проходить авторизацию.
3. Иметь работающую аннотацию, обеспечивающую исполнение в приоритете вне
   зависимости от других моделей авторизации, подключённых сверху неё
   (приоритетизирование модели).
4. Вести генерацию ключей отдельным микросервисом.
5. Иметь валидацию этих ключей со стороны проверяющих доступ микросервисов на
   базе публичного ключа.

Этой моделью авторизации мы, по сути, продемонстрируем, как работает обычная
авторизация на базе ролей пользователей. Мы не будем её слишком сильно развивать,
не будем добавлять на неё варьирование ролей и подобное — так как переданной
логики будет вполне достаточно для того, чтобы вы подобное решение сделали
самостоятельно.

А вот вторая (2) модель авторизации будет уже интереснее. Она будет внутри системы
для всего остального и будет линейной — такой же, как используется в системах
Amazon, Google и подобных игроков.

Очевидно, что в системах Google не может быть физически какой‑нибудь
«админки», где мы будем назначать права пользователям или их отзывать.

Аналогично для очень крупных систем практически возможна, но очень трудозатратна
ситуация, когда у нас появляются каскадные права, которые хочется проверять в
один запрос, как‑то:

+ пользователь является временным членом организации;
+ которая является (недавно стала, до этого была другая организация)
  владельцем группы;
+ которой принадлежит объект — картинка;
+ и ему надо управлять этой картинкой внутри этой группы;
+ управление которой возможно лишь для роли «оператор»;
+ внутри организации‑владельца.

Вот для того чтобы от этого отойти, и нужен линейный доступ на ключах.

Но мы пойдём даже дальше и в учебных целях эту линейную систему ещё и
усложним. И в итоге получим следующее:

# Модель авторизации на базе ресурсных ключей (Resource Key Auth)

## Основная философия:

1. При необходимости доступов к отдельным объектам они получаются тогда, когда
   это нужно, а не получаются «в принципе».
2. Простота разработки: авторизация, задаваемая на уровне контроллера, позволяет
   сразу же включить её и тестировать — не ожидая сложной общей модели
   авторизации.
3. Универсальный объект «пользователь»: любая системная сущность, способная
   владеть чем‑то, идентифицируется как «пользователь».
4. Право — это ключ к API и/или доступ к объекту, которым управляют.
   Владение объектом — это не поле, это именно наличие ключа на его распоряжение.
   Ключ — это: домен, тип объекта и квалификатор.
5. Технически «право» — это «scope» в OAuth‑токене. Владение объектом —
   это scope вида domain:object_type:action. Проверка прав — валидация scope
   стандартными средствами Spring Security OAuth2.
6. Объединяющие сущности вроде групп/организаций — это API‑сущности. Быть
   членом — значит иметь ключ к API этой группы.
7. Прямые права вместо каскадов: отсутствует наследование вроде «ты состоишь в
   группе», есть лишь прямое право на действие — либо через ключ от группы,
   дающий это право, либо через ключ в саму группу.
8. OAuth используется как транспорт — только стандартные инструменты: выдача токенов
   доступа от Spring OAuth‑сервера.
9. Безопасность на уровне гейтвея: все ключи проверяются в плане электронной
   подписи на уровне гейтвея. Внутри системы, в межмикросервисных запросах,
   электронная подпись не проверяется.
10. Проблемы отдельных элементов доступа решаются по мере их возникновения, а
    не досрочно и не забегая вперёд.
11. Система подразумевается:
    - разомкнутой;
    - подразумевающей, что большинство сценариев примитивные;
    - использующей стандарты OAuth 2.0;
    - масштабирующейся в основном за счёт Spring OAuthServer, не за счёт
      кастомной логики;
    - использующей @PreAuthorize/@PostAuthorize;
    - не зависящей от грандиозной системы авторизации (точечная авторизация),
      дающей гибкое добавление новых сущностей.

# Системные инструменты:

1. Модель авторизации работает на стандартных инструментах Spring, как‑то:
   OAuth‑сервер и клиент.
2. Для проверки доступа используется расширенный preauth от Spring (мы используем
   свои расширенные аннотации).
3. Фильтры доступа Spring Security мы не используем дальше, чем проверка
   прохождения аутентификации. Работаем средствами аннотаций над отдельно взятыми
   контроллерами/сервисами.
4. Для аутентификации используется адрес электронной почты.

# Как задаётся контроль доступа:

1. Контроль доступа задаётся к отдельно взятым контроллерам или в отношении
   отдельно взятых объектов, передаваемых на эти контроллеры.
2. Контроль доступа задаётся при помощи аннотаций над контроллером/сервисом.
3. Контроль доступа задаётся при помощи ключа, дающего права пользоваться
   отдельно взятым контроллером в отношении отдельно взятого объекта, передаваемого
   на такой контроллер.
4. При доступе проверяется Principal Spring, в котором есть отдельное поле, куда
   размещается конкретный ключ доступа.
5. Контроль доступа может также подразумевать время, в которое выдан ключ. Если
   лимит на доступ — 5минут, а ключ выдан 6минут назад, доступ не
   произойдёт, и это также регулируется аннотацией.

# Слепость контроля доступа:

1. Контроль доступа слеп к тому, кто и как получил ключ и каким образом.
2. Аннотация авторизации подразумевает, что если у получившего доступ есть ключ,
   следовательно, он авторизован выполнять действие.
3. Каскадно права не проверяются — отдельно взятому объекту доступа просто нужен ключ,
   демонстрирующий право пользоваться таким объектом доступа (объект доступа — доступ
   к контроллеру/сервису + право на объект, который туда отправляется или задаётся
   по публичному идентификатору).

# Корневые объекты:

1. Некоторые объекты в системе характеризуются как имеющие граф подчинённости:
    + «картинкИ группы» <- общий (главный) объект;
    + «картинкА группы» <- подчинённый объект.
2. В этом случае граф подчинённости задаётся явно (хранится в отдельной таблице базы данных).
3. В этом случае при получении доступа к общему (главному) объекту доступ предоставляется
   и к подчинённым объектам.
4. Модель нужна для тривиальных сценариев — «член группы имеет возможность видеть
   приватные фотографии внутри группы», что достигается тем, что просмотр осуществляется
   на уровне отдельного контроллера, который как раз и проверяет «общий» (главный) ключ.

# Каждый пользователь:

1. Авторизационные объединения, такие как «группы» или «организации», также в контексте
   системы трактуются как «пользователи».
2. Объекты системы не ведут своих владельцев/участников напрямую, но для простоты могут
   вести реестр ключей, выданных кому‑то, чтобы представлять это в виде списка
   владельцев/участников.
3. Владение организацией — это буквально наличие ключа типа «owner» к этой организации,
   выдаваемого на момент создания этой организации, отчего кто отображается во владельцах —
   тот, кто последним воспользовался ключом доступа к этой организации.
4. Членство подтверждается наличием ключа типа «participant» к этой организации.
5. Для получения доступа к объектам организации пользователь получает право на доступ
   либо к общему (главному) объекту, либо к отдельно взятому объекту; такой доступ
   выдаёт API этой организации/группы.
6. Модель подразумевает, что группа/организация может быть основным пользователем группы,
   так как группа по сути также является пользователем.
7. Модель подразумевает, что у группы/организации может быть сколько угодно владельцев
   или партисипантов.
8. Микросервисы также действуют как пользователи, однако в нашей системе авторизации их права
   на доступ всегда уровня «администратор» и задаются параллельной системой авторизации.

# Типичное флоу доступа к объекту группы:

- Пользователь хочет изменить картинку внутри группы «My».
- Изменение картинки внутри группы делается через контроллер changeMyGroupImage.
- Контроллер изменения картинки требует ключа уровня «participant» и «operator»
  и идентификатор картинки.
- Ключ на доступ к картинке получается с API группы, к которой относится пользователь.
- Пользователь, будучи и участником, и оператором, идёт в API группы и получает ключ
  на доступ к объекту картинки.
- То есть у пользователя есть ключ типа «participant» и ключ типа «operator» от этой группы,
  которые ему выдал администратор группы (пользователь, обладающий ключом типа «admin» от группы).
- После чего, получив ключи, пользователь изменяет картинку через соответствующий API.

# Кеширование и проверка ключей:

1. Ключи проверяются на уровне контура системы.
2. Внутри системы ключам есть полное доверие — то есть трактуется JWT, но подпись
   и её проверка игнорируется в случае, если ключ начинает гулять между микросервисами.
3. Так как ключей возникает достаточно много, пользователи хранят свои ключи в отдельном
   хранилище ключей, откуда их получают по мере необходимости.
4. Ключи считаются валидными, и их подписи проверенными (ключ из кеша/хранилища
   ключей не валидируется на проверку электронной подписи).
5. Инвалидация ключа — это:
    - удаление ключа из хранилища ключей;
    - внесение ключа в реестр инвалидных ключей.
6. Для доступа к ресурсам пользователь не обязан хранить ключ в хранилище ключей, а может
   хранить его где угодно ещё.
7. Если пользователь пришёл без ключа, система проверит, есть ли ключ в хранилище,
   и, если его нет, пошлёт пользователя авторизовываться.
8. Если пользователь пришёл с ключом, система будет проверять ключ, с которым пришёл
   пользователь, и по факту проверки закеширует его в хранилище ключей. Проверять — значит
   в том числе проверить, не просроченный ли ключ.
9. Ключи в хранилище хранятся и кешируются согласно политике кеширования и хранения
   отдельно взятых ключей. Возможно, что для некоторых контроллеров они не будут
   кешироваться вообще. Это решается датой кеширования.
10. Старые закешированные ключи вычищаются из кеша шкедулером: на момент вычистки
    задаётся общая дата/время, до которой ключи отдельного пользователя считаются
    невалидными.
11. Пользователь может инвалидировать все свои ключи (выйти из системы), установив
    отметку в хранилище ключей «ключи инвалидны с даты и времени»; в этом случае все ключи,
    выданные раньше этой даты, будут считаться инвалидными.
12. Экспайред ключи также размещаются в хранилище ключей в отдельном разделе.
13. Общее правило: сервис ничего не знает о системе авторизации, но если к нему пришли
    с ключом, обязан проверить, не отозван ли данный ключ; как то, имеем флоу:

        Запрос с ключом → [Сервис] → Проверка:
            1. Ключ валиден? (подпись/формат)
            2. Ключ не отозван? (чек в реестре)
            3. Scope подходит?
            → Бизнес‑логика

# Содержательная часть ключа:

1. Квалификатор задаётся так:
    - ишьер;
    - домейн;
    - объектныйТип;
    - квалификаторВВидеАйди — список.
2. При обработке токен становится частью принципала и следует за ним для уточняющей
   авторизации.

На этом с авторизацией всё.

Как я и сказал, мы сознательно делаем некоторый оверинжиниринг и дробим систему
авторизации на две части, чтобы показать, как это будет работать, и дать прочувствовать
механику безопасности.

На этом с вводным разделом всё, поэтому не сбавляем темпа — давайте разберём
софт‑скилз, так как разработчик является неотъемлемой частью самой разработки
(о чём многие почему‑то забывают), и будем переходить к кодированию того, что мы тут
напланировали и намоделировали.
