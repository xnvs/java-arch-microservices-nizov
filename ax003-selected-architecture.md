[оглавление](README.md)

# Выбранная архитектура

Отлично, мы разобрались с принципами разработки — впереди нас ждёт
выбранная модель авторизации, а пока давайте разберём архитектуру.

Я специально для этой книги разработал архитектуру, которая позволит нам
разобрать каждую из технологий Spring и показать её во всей красе. При этом
я решил сразу сделать хорошую рабочую production‑ready архитектуру — хотя и с
некоторым overengineering (всё‑таки она учебная).

Сразу хочу отметить насчёт архитектур в целом: архитектура подбирается под
ситуацию и коррелируется под принципы разработки и модель авторизации.

Когда архитектура описывается, это не подразумевает, что правила, в ней
указанные, нарушаться не будут (мы даже укажем это в одном из разделов). По
сути, что такое архитектура? Это не достижимый идеал, утопия в
проектировании и реализации. В реальности правила, указанные в ней, мы,
конечно же, будем нарушать — и не раз.

Архитектура нужна нам для того, чтобы понимать, что в принципе мы будем делать,
каким образом и с помощью чего. Например, если мы говорим «человек», мы
подразумеваем, что он на двух ногах. И когда мы проектируем дорожку для
ходьбы, мы планируем, что этот «человек» будет ходить по ней двумя ногами, а
не ездить по ней на гусеничном треке, прикреплённом к его голове.

Вот для решения таких связывающих моментов, по сути, архитектура нам и нужна.

По сути, в реальности мы можем задать градацию порядка:

    0%—Хаос(каждый пишет где хочет)
    30%—Бардак(есть patterns, но все их нарушают)
    60%—Эффективность
    90%—Догма(слепое следование, даже когда мешает)
    100%—Утопия(не существует)

Наша задача — как раз добиться эффективности, то есть консистентности в 60–80%
соответствия того, что архитектура задаёт, и того, что в системе будет
содержаться. Диктат архитектуры должен балансировать между ригидностью, которая
мешает работать, и полным бардаком, который также мешает работать.

И ещё заметьте: архитектура отделена от принципов и от модели авторизации — это
принципиальные моменты.

Итак, наша архитектура:
----------------------

Для примера назовём нашу архитектуру `!CAT` — архитектура на базе
смарт‑контрактов (`C`ontract `A`rche`T`ypes).

#### Нарушение правил и контроль хаоса:

+ Архитектура создаётся не как чёткие требования, а как ориентир для создания
  элементов и объектов системы — чтобы система существовала как минимум как
  система.
+ Конкретный выбор элемента или объекта диктует не архитектура, а требования к
  реализации отдельно взятой фичи (функциональности).
+ Однако отклонение от того, что передано в архитектуре, должно быть как минимум
  обосновано. Это обоснование указывается в виде ARD или хотя бы комментария.

#### Передача предназначения стереотипами и домейнами:

+ Архитектурные стереотипы относятся к объектам‑микросервисам — передают их
  назначение и выбор тактики работы, а также к отдельно взятым компонентам
  внутри них — передают их назначение.
+ Стереотипы убирают необходимость писать развёрнутую документацию: если объект
  подпадает под стереотип, он наследует на себя все его признаки.
+ Объекты подпадают под стереотип через именование. Если объект включает в
  названии имя стереотипа, подразумевается, что в нём есть все признаки
  стереотипа.
+ Стереотипы разделены по логическим домейнам, которые делят систему на верхнем
  уровне. Примером логического домейна являются «бухгалтерия», «финансовые
  операции» и так далее.
+ Имя домейна всегда включается в имя любой передающей его сущности — так мы точно
  знаем, куда объект относится.
+ Список видов стереотипов определяется архитектурой — поэтому не может
  появиться объект, непонятно к какому стереотипу относящийся.
+ Стереотипы изначально реализуются в виде прототипов, а в дальнейшем, попадая
  в код решения, копируются и донастраиваются. Стереотипы‑прототипы хранятся
  в системе в отдельном домейне — домейне Прототипов/Шаблонов.

#### Передача логики решений:

+ Логика решений может относиться либо к бизнес‑логике (ею управляют
  смарт‑контракты), либо к общей логике реализации (ею управляют системные
  стереотипы).
+ В любом случае, кто бы ни управлял логикой на верхнем уровне, на нижнем уровне
  она передаётся специальным образом.
+ На нижнем уровне она передаётся логическими абстракциями — каждая имеет своё
  чёткое и понятное наименование:

    - Стратегиями/правилами — отвечают на вопрос «что делать?», например
      использовать рублёвый перевод или SWIFT.
    - Стейт‑машинами — отвечают на вопрос «когда делать?», задают порядок
      обработки шагов и переходы между ними.
    - Процессорами — отвечают на вопрос «как делать?», определяют каждый
      отдельный шаг и код, передающий его содержание.
    - Конфигурационными объектами или спецификациями — отвечают на вопрос
      «откуда брать параметры?» для указания параметров и формул. Например,
      если «списание 20%», эти 20 % — часть объекта спецификации.

+ Транзакции и саги, связанные со стейт‑машинами/процессорами, хранят в себе
  идентификаторы того объекта, с которым они связаны (обычно это стейт‑машины).


#### Передача бизнес‑логики через смарт‑контракты:

+ Там, где логика относится именно к бизнес‑логике — какому‑то процессу, имеющему
  название в реальности, — она всегда передаётся явно на верхнем уровне, будучи
  объединённой в сущность контракта.
+ Смарт‑контракты в системе работают по архитектурному стилю смарт‑контрактов из сети
  Эфириум: стараются стремиться к контрактному праву из реального мира, придерживаясь
  их формы и содержания, передавая собою правоотношения и зависимости сторон.
+ Смарт‑контракты пишутся на Java и представляют собою в терминах Spring компоненты
  с внутренним персистенсом и подключением к ивентам.
+ В случае если к системе подключается реальный смарт‑контракт, он синхронизируется
  с системой через смарт‑контракт, написанный на Java.
+ Смарт‑контракт внутри себя содержит отдельные для него стейты, которые связаны
  в обязательном порядке с отдельным для него персистенсом.
+ Каждый смарт‑контракт имеет для себя свой отдельный репозиторий.
+ Смарт‑контракт выбрасывает события, однако не обрабатывает события (логика —
  аналогия с эфириум‑смарт‑контрактами). Обработчиком событий для смарт‑контракта
  должен быть иной объект. Смарт‑контракт для реализации логики внутри себя поддерживает
  лишь вызов собственных публичных методов.
+ События, выкидываемые смарт‑контрактом, считаются юридически значимыми
  и подтверждают факты совершения или осуществления отдельно взятых действий. События
  могут сопровождаться объектами (первичкой), хранимыми внутри смарт‑контрактов
  и при необходимости дублируемыми в бухгалтерском модуле.
+ Смарт‑контракт представляет объединение внутри себя: стратегий, стейт‑машин,
  процессоров и конфигурационных объектов, которые чётко замкнуты на конкретном
  смарт‑контракте.
+ Если смарт‑контракт несёт баланс, такой баланс задаётся для смарт‑контракта
  в бухгалтерском модуле.
+ В случае если смарт‑контракт должен быть связан с реальностью, он связывается
  с нею через оракула — то есть через сервис/сервисы, дающие ему корректные данные
  о состояниях какого‑либо процесса.
+ Смарт‑контракты хранятся в отдельном домейне — домейне контрактов. Если требуется
  менеджер синхронизации с блокчейном, он находится именно там.
+ Смарт‑контракт отличается от сервисов Spring логически, так как не оперирует
  буквально ничем, кроме своих внутренних состояний. Смарт‑контракт оторван от остальных
  компонентов системы и представляет собою полностью самодостаточную экосистему,
  не знающую ни о чём, кроме как об оракуле, бухгалтерском модуле и об объекте
  персистентности для хранения собственных стейтов.
+ По сути, смарт‑контракт — это более высокая часть бизнес‑логики, объединённая
  в одну систему‑процесс.
+ Когда программируется какая‑то логика внутри системы и требуется дополнительная
  функциональность, логически не включённая в функциональность смарт‑контракта
  (управлять собственными состояниями), к смарт‑контракту добавляется отдельно взятый
  менеджер — то есть микросервис, знающий уже о том, как работает система вокруг него
  и способный в том числе принимать события.
+ Смарт‑контракт идентифицируется отдельным уникальным идентификатором — аналогом
  адреса в Эфириум — и может по такому адресу обращаться и к другим смарт‑контрактам,
  используя для этого общего менеджера смарт‑контрактов или своего отдельного менеджера
  смарт‑контракта.
+ Отдельный менеджер смарт‑контракта обычно обслуживает контракты отдельного типа
  или связанных типов; его роль вытекает из общей бизнес‑логики.
+ Смарт‑контракт, не являясь просто сервисом или компонентом, представляет собою
  законченный отдельный объект с множеством стейт‑машин и состояний, таким образом
  может быть полностью сериализирован на логическом уровне. В реальности же, будучи
  идентифицирован по уникальному идентификатору, в своих методах получает по этому
  идентификатору состояния своих отдельных стейтов, стейт‑машин и конфигураций.
+ Смарт‑контракт является отдельным значимым субъектом системы, как уже было указано
  ранее: отправляет события и отвечает за свой персист, но при этом может ещё
  и создавать первичные документы через бухгалтерский модуль, которые подписывает от себя
  (как от контракта).
+ В бухгалтерском модуле для каждого смарт‑контракта есть отдельный счёт с его
  балансом/балансами и историей проводок.

#### Отчётность внутри системы:

+ При появлении новых элементов в системе по умолчанию задаются две механики отчётов:
    - историческая выборка по идентификаторам;
    - выборка по параметрам полей с помощью CriteriaAPI.
+ Любой пользователь может посмотреть отчёты по собственным созданным объектам.
  Таким образом, если пользователь указан как создатель объекта, он его видит в отчётах.
+ Новые виды отчётов добавляются лишь в момент, когда они кому‑то нужны. Таким
  образом действует правило: нет пользователя отчёта — нет отчёта.
+ За построение отчётов BOD/EOD отвечает отдельный менеджер домейна «Отчёты»,
  а эти отчёты собираются в отдельный репозиторий.

#### Хексагональность архитектуры:

+ Инфраструктура отделена от бизнес‑логики и не знает о её существовании — даже
  в случае логического совпадения REST‑эндпоинта и действия бизнес‑логики.
+ Всё, что может сделать инфраструктура, — это послать сообщение или принять сообщение.
+ Взаимодействие инфраструктуры с слоем бизнес‑логики построено на Spring‑ивентах.

#### Обработка событий (ивентов) и команд внутри системы:

+ События, подразумевающие необходимость совершения каких бы то ни было действий,
  представляются ивентами, называемыми командами.
+ Команда — это объект, имеющий адекватное именование и несущий в себе:
  пользователя, выполняющего команду, в виде идентификатора, и данные этой команды.
+ Команда может быть в том числе реакцией на ивент (реакция). Например, хандлер
  получил ивент и отправил в систему несколько команд. Это нормальное поведение, но оно
  должно быть изолировано на уровне отдельного менеджера (микросервиса) в системе.
+ Является ошибкой включение обработки команд в смарт‑контракт, так как смарт‑контракты
  отвечают лишь за своё состояние и не подразумевают взаимодействие с компонентами системы.
+ Точка входа в бизнес‑логику — это хандлер команды, посылаемой через Spring‑ивент,
  работающий или асинхронно, или синхронно (чаще асинхронно).
+ Не имеет никакого значения, что являлось изначально источником события — Kafka,
  сокет, REST и так далее.
+ Отправляя событие, его отправляют в любом случае в виде события Spring на хандлер Spring.
+ Ивенты поделены на два типа: внутренние (IN_) и внешние (OUT_).
+ Обработчик Spring, видя, что событие IN_, производит вызов отдельного сервиса
  внутри инстанса.
+ Обработчик Spring, видя, что событие OUT_, производит вызов брокера сообщений
  с этим событием.
+ Из‑за того, что в системе есть отдельный промежуточный приёмщик события от Spring,
  мы можем легко заменять IN_ на OUT_ и наоборот, достигая таким образом оптимизации.
+ Общая логическая модель:



    Внутреннее событие:
    (компонент) -> событие(_IN)  -> (обработчик события Spring) -> вызовСервисаВИнстансе
    
        Внешнее событие:
        (компонент) -> событие(_OUT) -> (обработчик события Spring) -> 
                       отправкаСобытияВБрокерСообщений ->
                       хандлерСообщенияОтНапримерКафки ->
                       событие(_IN)  -> (обработчик события Spring) -> 
                       вызовСервисаВИнстансе
    
        Пример в виде флоу:
            а. бизнес логика создает OUT_CREATE_ORDER
            б. OUT_CREATE_ORDER попадает в ивент хандлер Spring
            в. хандлер этот ивент пакует и отправялет через транспорт (например кафку) 
               как сообщение либо делает его бродкаст
            г. принимающий хандлер создает сообщение IN_CREATE_ORDER и 
               отправляет его внутрь спринга
            д. принимающий хандлер ивента Spring вызывает отдельный 
               метод отдельного сервиса
    
        В случае если все находится в одном инстансе:
            а. бизнес логика создает IN_CREATE_ORDER
            б. принимающий хандлер ивента Spring вызывает 
               отдельный метод отдельного сервиса

+ Логическая модель исключает брокер сообщений или любой другой транспорт и позволяет
  сосредоточить всю логику вокруг событий Spring, просто задавая им итоговый тип,
  который будет влиять на роутинг. Это, в том числе, позволяет тестировать логику
  только на IN_ сообщениях — поскольку любое OUT_ сообщение в итоге завершается
  IN_ сообщением.

+ Сообщения и их обработчики задаются парами — чтобы была возможность переключаться
  между ними. При этом понятно, что IN_ событие будет создано в любом случае:
  хандлер, принимающий событие из брокера сообщений, как раз и выполнит такое
  преобразование.

+ За транзакционность исполнения сообщений отвечает хандлер, который преобразует
  сообщение из OUT_ в IN_ вариант. IN_ вариант события всегда выполняется в том же
  инстансе, где оно было получено.

+ События смарт‑контрактов всегда имеют тип OUT_, поскольку настроены на работу
  внутри всей системы — во всех микросервисах.

#### Функциональные роли микросервисов (архитектурные стереотипы микросервисов):

+ Системные микросервисы, например:
    - микросервис‑бухгалтерии;
    - микросервис‑файлов;
    - микросервис‑базовой‑авторизации ит.д.

  Зона ответственности:
    - исполнять системную функцию, общую для всех элементов системы;
    - быть системой в системе (их существование по умолчанию подразумевается,
      а поведение предсказуемо).

##### Микросервисы бизнес‑логики

Микросервис, управляющий объектами, — «микросервис‑коробка»:
- зона ответственности — управлять типом объектов, быть для них «складом» и учётом;
- единая точка ответственности за тип объектов;
- старается не допускать прямого доступа к себе, минуя того или иного менеджера;
- доверяет менеджерам, не обеспечивая внутреннего контроля — за исключением контроля
  доступа отдельных менеджеров;
- при высокой связанности объектов, используемых в единственном контексте, хранит
  весь граф объектов (например: торговый центр — этаж — магазин). В абстракции
  объектов торговый центр может храниться в одном микросервисе‑коробке — для
  ускорения работы и нормализации логики;
- всегда проектируется с REST‑интерфейсом, даже если логически он не нужен.
  Например, коробка, обрабатывающая чат‑переписку, тестируется и управляется
  суперпользователями системы (администраторами) именно через такой интерфейс.

Микросервис, управляющий бизнес‑логикой, — «микросервис‑менеджер»:
- зона ответственности — операции и функционалы;
- изолирован от взаимодействия с другими менеджерами, является единой точкой
  ответственности за операции; не имеет ограничений в реализации собственной
  операции, если она эффективна, масштабируется горизонтально;
- в исключительных ситуациях возможен менеджер, управляющий другими менеджерами
  для исполнения своей логики, — но не более одного уровня вверх. В нормальном
  сценарии взаимодействует с системой, только выкидывая события и ожидая на них
  ответа, без прямого взаимодействия с другими менеджерами;
- управляет стейт‑машинами и смарт‑контрактами (сохраняет и загружает их
  по своему усмотрению), относящимися к связанным с ним операциям. Старается вести
  бизнес‑логику именно на базе стейт‑машин и смарт‑контрактов;
- управляет микросервисами‑коробками, будучи в них авторизован как имеющий права
  на управление;
- может иметь собственный счёт в бухгалтерии, то есть быть источником и точкой
  назначения платежей — через наличие отдельного смарт‑контракта, ассоциированного
  с таким менеджером;
- принципиально отличается от смарт‑контракта тем, что знает о системе вокруг.
  Смарт‑контракт передаёт лишь внутреннюю изолированную логику: двигает стейты
  и отправляет документы. Менеджер обеспечивает точку входа в смарт‑контракты
  и взаимодействие.

Микросервис, управляющий временем зависимыми событиями, —
«микросервис‑планировщик»/«микросервис‑клиринга»:
- зона ответственности — события, возникающие с временной периодичностью;
- работает напрямую с бухгалтерским модулем, в том числе вычисляя несостоявшиеся
  операции.

##### Пример сценария с уточнением ролей и взаимодействия

Микросервис, управляющий объектами («коробка»): товар
- отвечает за создание, удаление, изменение, запросы по критериям, резервирование
  (блокирование) объектов;
- функционирует автономно;
- знает только о своих объектах;
- резервирует объекты согласно УИД запроса, под который делается резервирование,
  через оптимистичную блокировку.

Микросервис, управляющий объектами («коробка»): заказ
- демонстрирует аналогичное поведение.

Микросервис, управляющий заказами («менеджер»): менеджер‑заказов‑продажи‑в‑розницу
- целиком отвечает за продажи в розницу, пересекаясь с другими менеджерами только
  на уровне блокировок;
- имеет полный доступ к системе для исполнения своих операций (в том числе к
  нескольким базам данных);
- ничем не ограничен в реализации своей бизнес‑логики, если она относится к его
  роли (продажа в розницу);
- обладает знанием о микросервисах, которыми оперирует;
- ведёт учёт смарт‑контрактов, стейт‑машин и их событий.

Микросервис, управляющий заказами («менеджер»): менеджер‑заказов‑продажи‑оптом
- демонстрирует аналогичное поведение, но применительно к процедурам продажи оптом.

Микросервис «планировщик»: микросервис‑клиринга
- отвечает за корректность учёта заказов;
- отмену неисполненных операций;
- разблокировку заблокированных, но неисполненных заказов и товаров.

##### Подтипы менеджеров

(Варианты менеджеров; выбор диктуется конкретной ситуацией. Вне зависимости от варианта
они используются для обеспечения операций резервирования):

+ Транзакционные — обладают подключением к нескольким репозиториям, выполняют
  операции, ориентируясь на себя и только на эти репозитории.

+ Saga‑подобные — имеют подключения к нескольким «коробкам» или «менеджерам»
  для исполнения сложных операций, по которым уже реализована какая‑то логика.


##### Исходный код

+ Исходный код микросервисов, используемых для бизнес‑логики, может
  дублироваться, однако при достижении критического уровня бардака его стараются
  выносить именно в стейт‑машины и смарт‑контракты. Вынесение общего кода
  микросервисов стараемся избегать, поскольку рассматриваем их как конечное решение,
  которое в итоге можно будет переписать целиком или версионировать.

##### Хранение

+ Если таблицы нескольких микросервисов хранятся в одной базе данных и в них есть
  разделение на владельцев, это задаётся префиксом таблиц — он чётко соотносит эти
  таблицы с именем микросервиса.

#### Устройство бухгалтерского модуля:

1. Использует бухгалтерские абстракции и именования в работе и пропускает через себя
   все операции, связанные с финансами или ресурсами.
2. Представляет собой архитектурный консистентный монолит, в том числе с
   совершением пессимистичных блокировок в базах данных.
3. Бухгалтерский модуль ведёт главный счёт системы и подсчёты с детализацией по
   категориям пользователей, смарт‑контрактов и менеджеров (через смарт‑контракты).
4. Бухгалтерский модуль не занимается ивент‑сорсингом: он ведёт учёт
   документарно — проводки привязываются к отдельно взятым документам, у которых есть
   основание и автор, а уже к ним привязываются проводки.
5. Создать проводки в бухгалтерском модуле без документа напрямую невозможно.
6. Дополнительно бухгалтерский модуль контролирует распределённые операции, когда в
   одной бизнес‑операции действует несколько микросервисов: (отгрузка со склада)
   <-> (оплата отгрузки со склада) <-> (принятие денег).
7. Бухгалтерский модуль ведёт первичные документы для смарт‑контрактов (смарт‑
   контракты получают к ним доступ из бухгалтерского модуля).
8. Бухгалтерский модуль содержит всё необходимое для подбивки итогов — это
   реализуется функционалом самого модуля, а не отдельных микросервисов.

#### Обзорность системы и данные для принятия решений внутри системы:

1. Система обзорна через ограниченный набор инструментов:
    - единая точка истинности — бухгалтерский модуль, откуда видны балансы и
      финансовые документы; операция считается завершённой, если она отмечена в
      бухгалтерском модуле;
    - событий и реестров событий;
    - отчётов, в том числе EOD/BOD.

2. Обзорность в системе проектируется под прямую потребность в ней и реализуется в
   виде отдельного отчёта или мастера отчётов. Универсальные отчёты в системе не
   планируются и не делаются.
3. Там, где действия подразумевают небухгалтерский контекст (не требуют введения
   первичного документа или документарного подхода), ведётся ивент‑сорсинг. На его
   базе при желании можно построить любые отчёты. Ивент‑сорсинг организован
   стандартным способом:
    - command/event (как запись);
    - eventStore (как репо ивентов);
    - aggregate (как представление операции, а не энтити — например,
      Transaction‑агрегат для MoneyDebited/MoneyCredited);
    - projection (как срез актуальных данных; может представлять собой просто
      сохранение данных в репозитории).

Ивенты агрегируются вокруг агрегата — поэтому он и называется агрегатом. В
результате мы получаем учётную таблицу:

    EventIdentifier :
    AggregateIdentifier :
    AggregateSequenceNumber :
    AggregateType :
    PayloadType :
    timestamp

#### Типичный флоу разработки:

+ Планируем функциональность (фичу).
+ Создаём смарт‑контракты (стейт‑машины, конфигурации и т.д.), подсчёты и
  первичные документы.
+ Пишем Cucumber для тестов.
+ Выполняем техническое исполнение тестов.
+ Добавляем нужные коробки.
+ Добавляем менеджеры.
