[оглавление](README.md)

# Soft Skills

## Тактический аджайл для организации процесса разработки

Как уже говорилось, часто забывают, что за архитектурами, технологиями и
интеграциями стоят разработчики. Поэтому я не могу обойти стороной момент, который
наблюдал неоднократно: проекты отлично планируют, чётко ставят задачи — а они просто
не выполняются или разваливаются в процессе, доводя разработчиков чуть ли не до
депрессии.

Поэтому в ближайших трёх главах мы поговорим о софт‑скиллах и общей
организации работы. Они напрямую связаны с разработкой микросервисов — а их главная
особенность это сложность, комплексность и высочайшая абстракция.

Начнём с организации работы в целом. А конкретно — с вопроса, как заставить
аджайл работать. Ведь темп изготовления итогового продукта не менее важен, чем сам
продукт. И именно аджайл решает эту проблему — как бы кому‑то ни хотелось видеть
ситуацию иначе.

Но сначала разберёмся с психологическими миражами.

Очень часто люди верят, что где‑то существует некая серебряная пуля. Она решит
абсолютно все проблемы — нужно лишь её освоить, правильно применить, выполнить
нужные ритуалы и так далее.

Кажется, будто где‑то есть человек, у которого всё получилось, — но не у вас.
То есть где‑то там, в другом месте, всё складывается, всё реализуется. А у вас
почему‑то бардак, хаос и всё зависло. Команда не хочет работать, и выглядит это,
мягко скажем, уныло.

Это мираж — то есть абсолютная нереальность.

И одним из таких миражей стал «аджайл» в своём изначальном виде.

При этом понятно, за что его так все ненавидят. Механика, задуманная для того,
чтобы «всё работало», превратилась в набор магических ритуалов — и само ядро системы
было потеряно.

В итоге мы имеем: с одной стороны — мираж, который шепчет, что всё будет
хорошо; с другой — реальность, показывающую, что на самом деле всё плохо. И нет
варианта, при котором это можно адекватно совместить.

Хотя это возможно — и возможно на тактическом уровне. Мы специально извлекаем из
системы то, что работает, адаптируем под свои условия и активно тестируем на
практике, параллельно удаляя всё, что не работает.

И система вдруг становится адекватной.

- Аджайл — это про стратегию.
- А к этой стратегии нужна тактика — то есть связь с реальностью изначально просто
  не была добавлена.
- В этом — огромная трагедия аджайла как философии.

В этой главе мы эту проблему исправим. Подход для исправления назовём
«Тактическим аджайлом».

Сразу замечу: как и в предыдущих главах, я даю лишь один из вариантов трактовки
философии, приближённый к реальности. Вы можете подстроить написанное здесь под
себя. Учитывайте также, что моя адаптация технически ориентирована — она создана
специально для объёмной и технологичной энтерпрайз‑разработки, близкой к
R&D. То есть когда от вас требуют рабочее решение, сделанное быстро.

Это обусловлено спецификой проектов, с которыми я работаю, и желанием показать
методологию, применимую даже отдельными разработчиками лично для себя.

Это раз.

Два.

Тактика организации работы построена на базе принципов разработки, которые я описал
ранее. Поэтому она естественным образом из них вытекает, будучи частью общей
системы.

Я надеюсь, что после прочтения этой главы вы измените своё отношение к аджайлу
(возможно, даже захотите его перечитать) и поймёте, как подстраивать работу под
свои условия.

Поехали.

Сначала я приведу правила — чтобы задать направляющие. Затем подробно разберём
каждый пункт: откуда он взялся, какую проблему решает и почему выглядит именно так.

Давайте смотреть на документ. Начнём с проблем, а потом пройдёмся по пунктам.
Ещё раз напомню: тактику мы пишем для команд быстрой и агрессивной реализации с
выводом продукта на рынок, близких к R&D. Для других видов команд её придётся
изменить.

# Тактический аджайл: сводка

## Проблемы, которые мы хотим решить и обозначаем как вектор атаки:

1. Болотная разработка — без начала, без конца, с постоянными пробуксовками.
2. Усреднённые постановки задач, при которых непонятно, кто какую задачу может
   выполнить.
3. Низкая мотивация — и динамика разработки в целом, и разработчиков в
   частности.
4. Сложная замена работников (создание незаменимых гуру).
5. Лотерея со сроками.

## Наша основная задача:

+ Максимизация на базе имеющихся на текущий момент ресурсов — ради решения, которое
  полностью работает.

## Чего мы добиваемся в целом относительно продукта:

1. Полноценной функциональной законченности на отрезке времени и из тех
   ресурсов, что у нас есть.
2. Отрезком времени выбираем одну неделю.
3. Из этого вытекают принципы:
    - Сделай законченный проект из имеющихся у тебя ресурсов за неделю.
    - Проект должен быть завершён целиком — то есть работать и быть
      функциональным.
    - Если у тебя есть базовый проект, правила не меняются: сделай законченный
      проект на его базе за неделю.

## Как мы решаем квалификационно‑командные вопросы:

1. Мы принципиально делим членов команд по квалификации.
2. Высококвалифицированные члены команд занимаются созданием прототипов и
   стереотипов.
3. Менее квалифицированные члены команд занимаются сборкой на базе типовых
   решений (стереотипов).
4. Действует принципиальный запрет на исполнение неквалифицированными членами
   команды нетиповых решений, прошедших стадию прототипирования.
5. Разделение команд и ролей в командах такое:
    - Высокая категория: прототипирование + постановка задач + фичи.
    - Средне‑высокая: типы тестов и задачи.
    - Средняя: реализация фич и тестов в коде, масштабирование.
    - Низшая: документация, приведение в порядок сетов данных, масштабирование.

## Как мы расставляем приоритеты в разработке:

1. Акцентируемся на нагнетании новой функциональности в большей степени, чем на
   поддержании уже работающего. Процентно мы больше идём вперёд, чем оглядываемся
   назад.
2. Беспощадно фокусируемся на промежуточном результате с законченной
   функциональностью — так, как если бы продукт нужно было сдавать целиком к концу
   срока. И как будто будущего продукта за пределами этого срока просто не
   существует.
3. Принципиально избавляемся и устраняем на начальном этапе любые идеи,
   связанные с перфекционизмом. Делаем лишь то, что можно сделать за отдельный
   промежуток времени — и чтобы это выразилось в отдельно взятую функциональность.
4. Принципиально выносим исследования и работу с непонятностями в отдельный
   флоу разработки. Он не связан с реализацией функциональностей на отрезке
   времени основными командами.
5. Добиваемся постоянного и неопровержимого чувства завершённости в работе к
   концу каждого отдельно взятого промежутка времени.
6. Используем в разработке BDD/TDD как основу работы и выражаем функциональность
   в тестах, которые появляются прежде, чем любая из функциональностей будет
   реализована в принципе.
7. Требуем от каждого члена команд выгрузку результатов работы на гит три раза
   в день — для поддержания внутренней дисциплины и обзорности динамики.

## Как мы видим реализацию отдельных частей в проекте:

1. Мы понимаем, что, поскольку проект к концу итерации должен быть финализирован,
   многие вещи, которые придётся добавить, в итоге придётся удалять, но мы на это
   принципиально идём.
2. Чтобы минимизировать количество технического кода, создающего законченность,
   мы максимально придерживаемся слабой связанности в компонентах.
   Планируя новую функциональность, мы стараемся реализовать её максимально
   изолированно.
3. Реализуя функциональность, мы не связываем её ни с энтити, ни с агрегатами,
   манипулируя уровнем сервисов.
4. Мы стараемся задавать значимую логику на уровне отдельных объектов —
   таких как стейт‑машины, — поддерживающих их тестируемость и замену целиком.

## Видение сложности и комплексности задач:

1. Мы понимаем, что задачи бывают 100% непонятные и 100% понятные,
   а также промежуточные варианты.
2. Мы берёмся реализовывать лишь 100% понятные задачи.
3. Если задача непонятная, мы отправляемся делать прототип отдельно от проекта,
   чтобы добиться того, что она станет понятной и её можно будет включить в проект.
4. Непонятные задачи мы не включаем в планирование, кроме как в виде создания
   прототипов. Прототипирование у нас проходит три фазы, которые включают в том числе
   документарное оформление каждой стадии:
    - рисеч;
    - обобщение и синтез;
    - сам прототип (proof of concept).

## Ведение двух проектов:

1. Технически, ведя проект, мы ведём два проекта, которые принципиально
   не смешиваем ни на уровне документаций, ни на уровне спецификаций.
2. Первый проект — это максимально огромный и неосязаемый, существующий в виде
   технического наброска:
    - по нему спецификация максимально подвижна и абстрактна;
    - конкретики нет;
    - есть много целей и идей;
    - он представляет собой направление, куда мы движемся.
3. Второй проект — это максимально конкретный проект, который мы собираем
   за неделю. Задачи по нему выбираются в направлении огромного «проекта»
   по принципу приоритета и понятности.

## Стандарты работы, которых мы в итоге придерживаемся:

1. Работа по окончанию периода должна быть окончательной. Проектом должна быть
   возможность пользоваться:
    - плохо, хорошо, удобно, неудобно — но должна быть возможность пользоваться;
    - этому задаётся максимальный приоритет, который в том числе призван избавить
      нас от не создающих подобный результат задач.
2. Задачи планируются на следующую неделю по выходным, чтобы быть отделёнными
   от основного рабочего флоу исполнения.
3. Задачи строятся так, что они развёрнуты линейно в чёткой последовательности —
   одна за другой. Последовательность задач должна быть понятной и обеспечена
   на этапе планирования, а не исполнения.
4. Задачи планируются и выбираются только тем, кто понимает, что он делает,
   то есть обладает квалификацией для планирования и линейного распрямления задач.
5. Работа делается так, что никаких заделов на будущее не вставляется.
   Проект реализует ровно те задачи, которые дают его законченность.

## Ведение рефакторинга:

1. Мы ведём глобальный рефакторинг, баг‑фикс и оптимизацию как одну большую задачу
   с одним большим результатом.
2. На эту большую задачу целенаправленно выделяется время,
   но не раньше чем на десятой итерации и не позднее чем на пятнадцатой.
3. Во время рефакторинга мы принципиально избегаем решения проблемы уродливого кода,
   поскольку понимаем, что некоторый код создан, чтобы быть уродливым.
4. Во время рефакторинга мы решаем проблемы, которые реально мешают работать, —
   то есть устраняем то, что реально мешает развиваться программе. Проблема выражается
   в реальных дополнительных затратах времени, и эти затраты не абстрактны,
   а понятны в часах.

## Научное обоснование (мы обоснуем выбор нашей тактики следующими пунктами):

1. Мы знаем, как работает когнитивная сложность, и сознательно переносим её внутрь
   системы.
2. Мы знаем, какие проблемы создаёт абстрактное планирование, и не допускаем его.
3. Мы знаем, что такое заумное решение, и не допускаем его.
4. Мы знаем, что основная проблема разработки — потеря динамики, и не допускаем этого.
5. Мы знаем, как работают зоны хаоса и порядка, и разделяем разработку на зону
   бардака (прототипирование) и на зону порядка (планирование из стереотипов).
6. Мы знаем, что потеря времени вызывается срывом приоретизации, поэтому поддерживаем
   искусственно созданную замкнутость в ресурсах.
7. Мы понимаем, как быстро документация становится неадекватной, поэтому поддерживаем
   самодокументирование процессом.
8. Мы понимаем, что программа должна решать реальные проблемы, но эти проблемы
   должны быть выражены в цифрах, поэтому работаем на базе user story, но передаём
   их в фичах, TDD/BDD‑тестах.
9. Мы понимаем позитивное влияние DDD, поэтому на недельном базисе наш проект
   отдестиллирован и всегда соответствует DDD.

Отлично, с документом разобрались. А теперь давайте разберёмся с тем, почему
возникли описанные выборы, поскольку многие из них могут казаться совершенно
неадекватными, пока не начнёшь разбираться с ними подробно.

## Обоснование тактических выборов

Что мы добиваемся в целом относительно продукта:

+ Мы добиваемся полноценной функциональной законченности на отрезке времени
  и из тех ресурсов, что у нас имеются в наличии.

обоснование:

То, что мы здесь делаем, — это решаем проблему того, что нам нужно сделать
и в какие сроки. Задавая границы фиксированными, мы снимаем с себя 90%
когнитивной нагрузки в совершении выборов, которые в целом проект будут двигать
вперёд крайне условно. Делая же простую максимизацию и ставя её в приоритет,
разработка вдруг становится максимально понятной и естественной.

+ Отрезком времени выбирается одна неделя.

обоснование:

Неделя — это ровно тот срок, который позволяет закончить минимум одну полностью
законченную фичу и сделать это хорошо. При этом это не тот срок, который
позволяет оттянуть исполнение до того момента, как оно станет похожим на болото.
По сути, недельный срок — это не только про то, чтобы сделать что‑то быстро,
а про то, чтобы изначально планировать только то, что можно сделать и сдать быстро,
то есть определять эффективность в том числе на базе ограничения сроков.

+ Таким образом, появляются принципы:
    - Сделай законченный проект из тех ресурсов, что у тебя есть, за неделю.
    - Проект должен быть закончен целиком, то есть он должен работать и быть
      функциональным.
    - В случае если у тебя есть базовый проект, правила не меняются: сделай
      законченный проект на его базе за неделю.

обоснование:

Опять же, принципы буквально трактуются научно как:
1. min/max локального состояния с принципиальным упором на такую максимизацию.
2. Отслеживаемость, конечность и допаминовая мотивация для команды.
3. Повторение паттерна на любом уровне.

## Как мы решаем квалификационно‑командные вопросы:

+ Мы принципиально делим членов команд по квалификации.

обоснование:

Разделять — значит контролировать. Мы принципиально делим не просто по квалификации,
но и по задачам. Таким образом, такое разделение позволяет видеть исполнение
соответственно роли. А разделение, которое не приводит к результатам, означает
видение ошибки — в случае если мы делим по квалификации и видим, что человек
не способен выполнять задачи.

+ Высококвалифицированные члены команд занимаются созданием прототипов и стереотипов.

обоснование:

Мы принципиально выделяем высококвалифицированных членов команды для обеспечения
работы низкоквалифицированных — вместо того чтобы локально забивать микроскопами
гвозди (что, очевидно, будет неплохо получаться, но сделает всю систему
неэффективной).

+ Менее квалифицированные члены команд занимаются сборкой на базе типовых решений
  (стереотипов).

обоснование:

Здесь же мы гарантируем, что завалить задачу, которая строится на масштабировании
прототипа, который ещё и оттестирован, будет просто невозможно.

Проще говоря, мы не даём людям с отсутствием квалификации возможности загоняться
и чувствовать себя плохо из‑за того, что им может попасться работа, которая им
просто квалификационно противопоказана — и которая будет приводить буквально к потере
динамики, так как человек в этой работе будет просто буксовать.

+ Действует принципиальный запрет на исполнение неквалифицированными членами команды
  нетиповых решений, прошедших стадию прототипирования.

обоснование:

Это ужесточение принципа на уровне запрета. Проще говоря, если ты старший
разработчик — делай и готовь материалы и базу для работы мидл‑ и джуниор‑разработчиков,
а не делай задачи, которые тебе просто так хочется делать, потому что у тебя это
получается (было бы удивительно, если бы у тебя это не получалось).

+ Разделение команд и ролей в командах производится следующим образом:
    - Высокая категория: прототипирование + постановка задач + фичи.
    - Средневысокая: типы тестов и задачи.
    - Средняя: реализация фич и тестов в коде, масштабирование.
    - Низшая: документация, приведение в порядок сетов данных, масштабирование.

обоснование:

Основная задача здесь — отделить высококвалифицированную работу от низкоквалифицированной
и принципиально гарантировать исполнение работы на среднем и низшем уровне, создав
там динамику.

Логика очень простая: основная работа, которая двигает проект, выполняется именно
на среднем уровне. Обеспечивая его динамику, мы обеспечиваем динамику всего проекта.
Вот в этой системе мы как раз и заставляем работников верхней квалификации не просто
идти и делать работу за средний уровень, а обеспечивать его инструментами и условиями
для исполнения такой работы.

## Как мы расставляем приоритеты в разработке:

+ Мы акцентируемся на нагнетании новой функциональности в большей степени, чем
  на поддержании уже работающего. Процентно мы больше идём вперёд, чем оглядываемся
  назад.

обоснование:

Логика здесь — не бездумное движение вперёд, как может показаться, а принципиальное
выделение процентного времени на движение вперёд, для того чтобы оно в принципе
случилось. Так как ретроспективно присутствуют множество проектов, которые буквально
являются закопанными сами в себе, потеряв любую динамику развития.

Здесь же мы принципиально говорим: нет. Какие бы у нас проблемы внутри проекта ни
были, вот эта часть времени будет потрачена на реализацию именно новых фич, а не
на регулирование старых.

+ Мы беспощадно фокусируемся на промежуточном результате с законченной функциональностью,
  так как если бы продукт нужно было сдавать целиком к концу срока — и как будто
  будущего продукта за пределами этого срока просто не существует.

обоснование:

В данном случае максимизируется эффект от того, что продукт должен быть конечным,
и трактовкой такой конечности. Так как, если не задать отрезания будущего, могут
возникать так называемые «функциональности с перспективой», но вот их как раз быть
и не должно.

Система должна быть консистентной — и именно это правило это и обеспечивает.

+ Мы принципиально избавляемся и устраняем на начальном этапе любые идеи, связанные
  с перфекционизмом, — так как делаем лишь то, что можно сделать за отдельный
  промежуток времени. Конечно, сделать за отдельный промежуток времени так, чтобы это
  выразилось в отдельно взятую функциональность.

обоснование:

В данном случае идея понятна: мы боремся с перфекционизмом. Нам нужно решение,
которое в ограниченный срок будет работать, а не решение, которое будет работать
идеально. Причём отсечка «хорошести» решения — это то, работает оно или нет,
а не то, как оно работает. Поскольку именно такой вариант разработки и выбран
приоритетом.

+ Мы принципиально выносим исследования и работу с непонятностями в отдельный флоу
  разработки, не связанный с реализацией функциональностей на отрезке времени основными
  командами.

обоснование:

Вынесение исследований в отдельный флоу — на самом деле это попытка вычистить
флоу плановой разработки от всего того, что не может быть быстро сделано на базе
понимания команды о том, как это делать.

Таким образом, вот эта вычистка основного флоу здесь имеет большее значение, чем
поддержание в рамках проекта работы по созданию прототипов.


+ Мы добиваемся неизменного и неоспоримого ощущения завершённости в работе
  к концу каждого конкретного временного промежутка.

обоснование:

Обоснование лежит на уровне самого человеческого восприятия итогов работы —
методология дарит чувство победы или дожимания победы в рамках недели.

Каждую неделю мы — победители.
Каждую неделю мы делаем мир вокруг лучше.
Мы чётко понимаем, что делаем и куда движемся.

Именно это и придаёт разработке «человечность».

+ В основе нашей работы — BDD/TDD, а функциональность мы выражаем через тесты,
  которые создаём ещё до реализации какой‑либо функциональности.

обоснование:

BDD/TDD, помимо прочего, гарантирует привязку к реальным задачам проекта
и к user story. Мы создаём функциональность — на какой базе? На базе user story.
А что такое user story? Это то, что технически продвигает проект вперёд
и помогает зарабатывать деньги.

Простая цепочка даёт нам не только ключевые преимущества BDD/TDD,
но и удерживает в рамках модели разработки, нацеленной на пользу и прибыль.

+ Требуем от каждого члена команды выкладывать результаты работы в Git
  три раза в день — чтобы поддерживать дисциплину и прозрачность динамики.

обоснование:

Это один из самых действенных способов отслеживать динамику разработки
и вовремя выявлять недочёты — он построен на модели «самоотчётности».
С одной стороны, разработчику так проще: это исключает прокрастинацию.
С другой — удобнее менеджменту: сразу видно, чем занят разработчик,
без лишних отчётов и уточнений.

Более того, поскольку модель выстроена вокруг задач и тестов,
мы в общих чертах видим, в каком состоянии каждая фича и чем занимается
разработчик. А уточнения при необходимости может дать даже ИИ — без дополнительной
коммуникации, если и так очевидно, что всё идёт хорошо.


## Как мы видим реализацию отдельных частей в проекте:

+ Мы понимаем, что, поскольку проект к концу итерации должен быть финализирован,
  многие вещи, которые придётся добавить, в итоге придётся удалять, но мы на это
  принципиально идём.

обоснование:

Это один из немногих минусов настоящей методологии: поскольку проект должен
завершиться результатом и может быть использован как законченный проект, может
возникнуть ситуация, что какая‑то вещь будет сделана лишь для того, чтобы
проектом можно было пользоваться.

Однако у этого недостатка есть и достоинство: может случиться так (и случалось так
во множестве случаев), что временное решение станет постоянным — и эта методология
как раз и делает это возможным.

+ Чтобы минимизировать количество технического кода, создающего законченность, мы
  максимально придерживаемся слабой связанности в компонентах. Так, планируя новую
  функциональность, мы стараемся реализовать её максимально изолированно.

обоснование:

Правило диктуется тем, что при разработке мы будем много удалять элементов из
системы в случае их эволюции. Отчего, чтобы это в принципе работало и было
возможным, мы должны, как следствие, вести низкую связанность и анемичность, о
которой будет следующий пункт.

+ Реализуя функциональность, мы не связываем её ни с энтити, ни с агрегатами,
  манипулируя уровнем сервисов.

обоснование:

Анемичность в разработке и отсутствие надежды на эффективно созданную ДДД‑модель —
это прямой опыт негативной разработки, при которой мы:

(1) Точно не знаем, чем будет являться объект, — и нам проще добавить несколько
сервисов, параллельно работающих с какими‑то данными, чтобы реализовать
функциональность, чем планировать что‑то грандиозное.

(2) Физически ограничены временными сроками для грандиозных высокоуровневых моделей,
поэтому просто физически можем успеть лишь сделать дополнительный сервис, но не
объёмную ООП‑модель.

+ Мы стараемся задавать значимую логику на уровне отдельных объектов — таких как
  стейт‑машины, поддерживающих их тестируемость и замену целиком.

обоснование:

Работа с отдельными объектами гарантирует адекватное тестирование этих объектов и
возможность вести TDD/BDD в разработке относительно этих объектов. Более того,
гарантирует возможность вырезать их из системы и заменить в случае необходимости.

Таким образом и получается, что, несмотря на начальную вроде бы сложность, не
вводя элементы разработки как объекты, мы скорее теряем, чем получаем — уже даже на
среднесрочном треке.

## Видение сложности и комплексности задач:

+ Мы понимаем, что задачи бывают 100% непонятные и 100% понятные, а также
  промежуточные варианты.

обоснование:

Речь идёт о принятии того факта, что большинство инженеров, когда занимаются
планированием, занимаются высказыванием вслух фантазий, не имеющих ничего общего с
реальностью. А поскольку нам с фантазиями работать не хочется, мы и вводим
градацию задач по понятности.

Что такое понятная задача? Понятная задача — это задача, по которой у нас нет ни
одного вопроса и сроки по которой мы можем назвать точно. Непонятная задача — это всё
то, что не является понятной задачей.

+ Мы берёмся реализовывать лишь 100% понятные задачи.

обоснование:

Мы можем успешно планировать лишь в отношении 100% понятных задач. Как только мы
начинаем запихивать в планирование ещё и рисеч, сроки планирования сразу становятся
шаткими, и всё планирование разваливается.

Это очевидный факт, который как раз и не позволяет эффективно планировать время,
которое выливается в отсутствие динамики и которое же заканчивается в итоге
срывами сроков или, что ещё хуже, враньём менеджерскому звену о результатах.

+ В случае если задача непонятная, мы отправляемся делать прототип отдельно от
  проекта, чтобы добиться того, что она станет понятной и её можно будет включить
  в проект.

обоснование:

Мы задаём прямой путь действий, который нужно будет совершить, чтобы задача в
принципе попала в планирование. То есть здесь имеет место чёткая конкретика без
исключений: задача, непонятная в любой части, из проекта снимается — без
исключений.

+ Непонятные задачи мы не включаем в планирование, кроме как в виде создания
  прототипов. А прототипирование у нас проходит три фазы, которые включают в том
  числе документарное оформление каждой стадии:
    - рисеч;
    - обобщение и синтез;
    - сам прототип (proof of concept).

обоснование:

Здесь имеет место техническое обоснование того, как двигается непонятая задача, прежде
чем она становится понятной. При этом имеется в виду не просто теоретическое
движение, а буквально составление документов.

Мы хотим изменить модель авторизации. Нам нужна теория: рисеч материалов — кто как
делает; синтез этих материалов в виде выжимки; и рабочий прототип с
демонстрацией того, как это будет работать.

Чистая конкретика, которую в том числе можно при постановке задач, связанных с этой
авторизацией, поставить на нижний уровень исполнителей.

## Ведение двух проектов:

+ Технически, ведя проект, мы ведём два проекта, которые принципиально не смешиваем —
  ни на уровне документации, ни на уровне спецификаций.

обоснование:

Здесь — принципиальное деление мечт и размышлений собственников проекта о том,
чем он должен в итоге стать, и работы, которая может и должна быть сделана
здесь и сейчас.

Если этого не делать, у нас будет уровень планирования «как победить в чемпионате
мира по бодибилдингу, будучи при этом 40‑летним человеком, два раза в неделю
ходящим в спортзал». Разрыв соотношения слишком высокий, и абстракция слишком
отличающаяся.

+ Первый проект — это максимально огромный и неосязаемый, существующий в виде
  технического наброска:
    - По нему спецификация максимально подвижна и абстрактна.
    - Конкретики нет.
    - Есть много целей и идей.
    - Он представляет собой направление, куда мы движемся.

обоснование:

Первый проект не ограничивает включение в себя чего угодно — это чистый хаос,
подстраивающийся под рынок, в котором есть место для любой идеи. Именно этим он
и хорош: каждый может прийти и добавить в него что угодно — чистая демократия.

+ Второй проект — это максимально конкретный проект, который мы собираем за неделю.
  Задачи по нему выбираются в направлении огромного «проекта» по принципу приоритета
  и понятности.

обоснование:

Второй же проект — это техническая выжимка нескольких задач из первого согласно
приоритетам того, что мы делаем и в каком направлении идём. Здесь нет места
неконкретности и какой‑то нечёткости — здесь только конкретные задачи и конкретный
флоу их выполнения.

Как соотносятся проекты? Очень просто — через выборку задач. Задачи технически
берутся из первого проекта и накладываются во второй так, чтобы результат был
конечным и при этом работал.

## Стандарты работы, которых мы в итоге придерживаемся:

+ Работа по окончанию периода должна быть окончательной. Проектом должна иметься
  возможность пользоваться.

  Плохо, хорошо, удобно, неудобно — но должна быть возможность пользоваться. Этому
  задаётся максимальный приоритет, который в том числе призван избавить нас от задач,
  не создающих подобный результат.

обоснование:

Здесь задаётся именно понятная формула: проектом должна быть возможность
пользоваться в том виде, как он есть.

Опять же повторю пример — что такое окончательность:

1) Есть огромный проект красивого игрового движка.
2) Там много систем, механик и тому подобного.
3) А есть задача сделать окно, которое открывается и закрывается.

Вот сделанное окно, которое открывается и закрывается, — это локально законченный
проект, который 100 % работает и которым можно пользоваться.

+ Задачи планируются на следующую неделю по выходным, для того чтобы быть отделёнными
  от основного рабочего флоу исполнения.

обоснование:

Попытка включить управление задачами в процесс исполнения этих же задач будет терпеть
фиаско раз за разом. Процесс планирования, с другой стороны, должен опираться на
конечные результаты исполнения — и вот как раз между сдачей работ и возникновением
новых работ и находятся выходные.

Это порождается механикой недельной работы, но для такого формата данное решение
крайне естественно.

+ Задачи строятся таким образом, что они развёрнуты линейно, в чёткой
  последовательности — одна за другой. Последовательность задач должна быть
  понятной и должна быть обеспечена на этапе планирования, а не исполнения.

обоснование:

Задачи мало написать — их нужно логически развернуть и выстроить в чёткой
последовательности друг относительно друга, чтобы они:

1) не мешались;
2) не создавали неоднозначности;
3) были полностью понятны;
4) были исполнимы;
5) ещё и закончились итоговым результатом в виде промежуточно законченного проекта.

Правило здесь — не только про то, чтобы это обеспечить, но и про то, чтобы
исключить возможность спускания некачественных задач на нижний уровень исполнения.

+ Задачи планируются и выбираются лишь тем, кто понимает, что он делает, то есть
  обладает квалификацией для планирования и линейного распрямления задач.

обоснование:

Что означает выбор человека, который понимает, что он делает? Это означает
физическое отстранение от процесса выбора задач людей, которые могут случайно
оказаться в такой роли.

История с тем, чтобы нанять даже на подряд человека за большие деньги для того,
чтобы управлять потоком задач, всегда будет более адекватной, чем в периоде работы
просто накидать каких‑то задач потому, что надо что‑то накидать. Пункт заставляет
об этом задумываться и исключать такое.

+ Работа делается так, что никаких заделов на будущее не вставляется. Проект
  реализует ровно те задачи, которые дают его законченность.

обоснование:

Здесь опять же происходит борьба с абстракциями и переносом сложности системы
внутрь системы. Нет ничего проще, чем улучшение того, что уже и так работает.
Вот именно это правило здесь и эксплуатируется во всей своей красе.


## Ведение рефакторинга:

+ Мы проводим глобальный рефакторинг, баг‑фикс и оптимизацию как одну большую
  задачу с единым итоговым результатом.

обоснование:

Рефакторинг, проводимый таким образом, ограничен по объёму, и время на него
выделяется с учётом этого ограничения. Давление временных сроков — один из ключевых
факторов системы, призванный обеспечить максимальный эффект.

+ На эту масштабную задачу целенаправленно выделяют время — но не раньше десятой
  итерации и не позднее пятнадцатой.

обоснование:

Такой расчёт гарантирует, что рефакторинг состоится: на него отводится от одной
десятой до одной пятнадцатой времени реализации. Это формирует разумное временное
ограничение, благодаря которому рефакторинг становится планомерным и здоровым,
а проект — хорошо структурированным.

+ Во время рефакторинга мы сознательно избегаем исправления «уродливого» кода,
  поскольку понимаем: некоторые фрагменты кода изначально задуманы как «уродливые».

обоснование:

Код, который выполняет свою функцию, — это хороший код. Даже если он выглядит
неэстетично, но справляется с задачей, с точки зрения бизнеса он остаётся
качественным.

Сохранение такого кода при наличии чётких границ его применения — признак зрелой
разработки и признания того, что идеала не существует. Рабочее важнее красивого.

+ В ходе рефакторинга мы устраняем только те проблемы, которые реально затрудняют
  работу, — то есть решаем вопросы, мешающие развитию программы. Проблема
  проявляется в конкретных дополнительных временных затратах, измеримых в часах.

обоснование:

Суть в том, что без реальной проблемы не нужно изобретать решение. На этапе
рефакторинга легко начать «улучшать управляемость» кода — но зачастую это
превращается в пустую трату времени. Ведь в будущем рефакторённый «идеальный»
модуль могут просто удалить.

Поэтому установка часовой меры проблемы помогает отделить реальные сложности от
надуманных.


## Научное обоснование (мы обоснуем выбор нашей тактики следующими пунктами):

+ Мы знаем, как работает когнитивная сложность, и сознательно переносим её внутрь системы.

обоснование:

Когнитивная сложность может быть в планах и головах разработчиков,
архитекторов, менеджеров проектов — или внутри системы.

Закопать сложность внутрь системы выгодно просто потому, что уровень сложности
в головах и планах будет снижаться. Мы подходим к работе так, чтобы как можно
больше сложности было внутри — и она была замкнутой. И, конечно, чтобы части этой
сложности не выходили наружу сделанных работ.

+ Мы знаем, какие проблемы создаёт абстрактное планирование, и не допускаем его.

обоснование:

Здесь имеется в виду типичная статистика: абстракция не реализованная один
зависит от абстракции не реализованной два. Первая абстракция спланирована
некорректно на 5 %, вторая — некорректно на 10 %, а ещё есть третья, которая
некорректна на 8 %. 95% * 90% * 92% — и мы уже уверены в решении лишь
на 78 %, то есть четверть наших решений изначально некорректны.

И ещё небольшое движение вперёд — ещё один рывок, и наша работа станет
настолько нерелевантной реальности, насколько возможно.

Отчего мы и избавляемся от долгоидущего абстрактного планирования, заменяя его
реальным — на уровне коротких задач.

Проще говоря, мы не говорим, что планирование — это плохо. Мы говорим, что
планировать на базе вещей, которые существуют лишь в наших фантазиях, — это
гарантировать статистический провал просто из самой механики допущения ошибки при таком
планировании.

Статистически планирование — это направление, а не путь. И мы как раз это и
манифестируем.

+ Мы знаем, что такое заумное решение, и не допускаем его.

обоснование:

Здесь имеется в виду история про комплексность формата $n!$, когда одно зависит
от другого, другое — от третьего, третье — от четвёртого. Это всё очень
гениально, очень разумно, очень красиво и… очень ригидно, то есть не поддаётся
быстрому расширению.

История здесь о том, чтобы система работала так, чтобы быть максимально
горизонтально масштабируемой. И вот каждый процесс здесь построен так, что он
изначально прост и изначально несложен.

Неделя срока — несложно,
три коммита в день — несложно,
и так далее.

Можно ли систему сделать «умной»? Безусловно.

Станет ли она от этого более эффективной? Конечно — но в каком‑то очень
локальном моменте, а во всём остальном — нет. Здесь же речь как раз и идёт о том,
чтобы делать решения, которые работают плюс‑минус всегда, а не для отдельного
случая.

+ Мы знаем, что основная проблема разработки — потеря динамики, и не допускаем этого.

обоснование:

Динамика теряется от потери мотивации, от ригидности (зарегулированности) или от
потери контроля над процессами.

Наша система принципиально именно с этими моментами и борется — буквально. Это в неё
прямо вшито.

+ Мы знаем, как работают зоны хаоса и порядка, и разделяем разработку на зону
  бардака (прототипирование) и на зону порядка (планирование из стереотипов).

обоснование:

Вообще можно говорить о том, что делить работу на хаос (то есть бардак,
обеспечивающий динамику и движение вперёд) и на порядок (то есть движение по
ригидным рельсам) буквально гарантирует проекту, что он не повязнет в бюрократии,
будучи закопан в правилах и правильности, и при этом не поддастся истории, когда
потеряет управление.

По этой же причине зона хаоса и бардака отправляется в управление
высококвалифицированным работникам, а снизу — на среднем и низшем уровне — уже
поддерживается относительный порядок.

И третий момент здесь: мы легко можем регулировать количество людей, работающих на
прототипировании и на итоговой сборке. То есть зоны хаоса и порядка в плане
менеджмента не смешиваются.

+ Мы знаем, что потеря времени вызывается срывом приоритизации, поэтому поддерживаем
  искусственно созданную замкнутость в ресурсах.

обоснование:

Здесь история более глубокая, чем может показаться на первый взгляд. Дело в том, что
корректно расставить приоритеты невозможно практически ни в одном из случаев — то
есть всегда будет возникать ситуация, когда приоритеты нарушены. И вот здесь
заявленная механика делает очень простую вещь: она не даёт нарушению приоритетов
зайти слишком далеко вперёд, искусственно купируя такое забегание на временном
участке и требуя делать следующую бизнес‑ориентированную задачу.

+ Мы понимаем, как быстро документация становится неадекватной, поэтому поддерживаем
  самодокументирование процессом.

обоснование:

Большая часть документации — это проектные описания того, как и что должно быть. В
нашем случае, снижая горизонт планирования практически до критического минимума, мы
избавляемся от потребности забегать планировать вперёд вообще. Принципиально
выставляя вперёд второй абстрактный проект, в который при желании можно написать что
угодно кем угодно.

Но в рамках недельного плана, представляющего по сути наборы распрямлённых задач,
глубокое планирование как таковое фактически не нужно.

+ Мы понимаем, что программа должна решать реальные проблемы, но эти проблемы
  должны быть выражены в цифрах. Поэтому работаем на базе user story, но передаём их
  в фичах, TDD/BDD‑тестах.

обоснование:

Решение того, что не является проблемой, — очевидная беда. Но как понять, что есть
проблема, а что нет? Очень просто: ввести градацию того, насколько то или иное
событие мешает движению проекта, и оценить его как раз в часах, деньгах, ресурсах, а
не просто в историях «нравиться/не нравиться».

Более того, когда затевается что‑то новое, это что‑то новое как минимум также
должно коррелироваться с историей о том, что проект делается как коммерческий — то
есть он должен в итоге зарабатывать деньги, то есть быть ориентирован на конкретную
бизнес‑логику.

А конкретность бизнес‑логики — это как раз user story → TDD/BDD. Иначе она
будет просто размытой, непонятной и неясно, для чего нужно.

+ Мы понимаем позитивное влияние DDD, поэтому на недельном базисе наш проект
  отдистиллирован и всегда соответствует DDD.

обоснование:

Одна из историй DDD — создать законченное полноценное решение, достаточное для того,
чтобы передать развитие системы к моменту времени. По сути, наша тактика направлена
также на это.

Так как к концу периода работ всё лишнее из него выброшено, а всё рабочее, что
можно было сделать за период, оставлено.

