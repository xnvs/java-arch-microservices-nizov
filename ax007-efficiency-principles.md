[оглавление](README.md)

# Принципы эффективности

Любые методики и понимания среды ничего не стоят, если вы не эффективны, если
не можете довести дело до конца, если не можете добиться результата.

В этой главе мы заканчиваем разговор о софт-скиллах и поговорим о некоторых
неочевидных принципах, которые способны сделать вас и вашу работу, а также
работу вашей команды, если вы работаете не один, максимально эффективной.

У меня есть чёткое видение, что эффективность по своей сути больше похожа на
жизненную позицию, придерживаемую набором достаточно не всегда очевидных
принципов. Вот здесь я и предлагаю их перечислить и обсудить.

Хочу также отметить, что я написал две неплохие главы по личной эффективности:
о том, как бороться с прокрастинацией и страхами. Вы их можете почитать в моей
книге про алгоритмы и структуры данных.

Но вернёмся к эффективности.
Многие моменты здесь будут перекликаться с тем, что мы уже рассказали и
описали, но под углом именно вашей эффективной деятельности (которая, как я
подразумеваю, направлена на создание систем, работающих на микросервисах),
которой мы их хотим в итоге достигнуть.

Я не буду группировать принципы, а приведу их в том порядке, в котором одни из
них являются базой в большей степени для развития других, для того чтобы
понимание базовых принципов влекло за собой лучшее понимание последующих.

Можно ли говорить, что из них какие-то более важные, а какие-то меньше?
Скорее нет, чем да. Однако базовые принципы (первые, идущие в списке) будут
накладывать свой отпечаток на все последующие как раз в большей степени, чем
остальные.

## Принцип понимания того что вы на самом деле делаете:

Самый базовый навык, который стоит освоить и принять, — это буквально навык
понимания того, что вы сейчас делаете вообще и куда это вас в принципе ведёт.

То есть буквально умение останавливаться, осматриваться вокруг и направлять
себя в нужное направление. Так как вероятность того, что вы будете находиться
как белка в колесе вокруг какой-нибудь бестолковой задачи или логической
ловушки, не просто высока, но я бы даже сказал, максимальна. И если этого не
купировать, этот процесс может длиться буквально годами.

Приведу простой пример: команда начинает делать стартап и делает для него
редактор HTML, который позволяет редактировать страницу в браузере. Почему? —
Потому что так получилось. Команда думает: какое интересное решение, это же
можно оформить что угодно, например, документацию. А документация — это же по
сути курс (и не поспоришь же). То есть мы делаем, выходит, стартап для курсов.
Ну так надо их и продавать. Команда оформляет это в виде проекта по продаже
курсов, делает лендинг с описанием того, чего только можно не достигнуть с их
чудо-продуктом. И... результат закономерен.

Логика здесь существует на двух уровнях:

Первый уровень достаточно понятный — отсутствие итогового направления пути не
позволяет даже гипотетически выбрать эвристику, которая бы вас к нему
направляла бы. А если нет эвристики, нет даже формальной ошибки. Нет ошибки —
следовательно, нет понимания того, что вы что-то не то делаете. А если нет
понимания того, что вы что-то не то делаете, вы буквально всегда делаете
что-то не то.

Таким образом, у вас должно быть понимание того, что вы хотите сделать в
принципе, а также понимание того, что вы сейчас делаете и зачем, и куда вас
это ведёт.

Второй уровень здесь чуть более глубокий.

Это мышление уровня "нужно знать абсолютно всё, чтобы понять куда идти и
зачем идти". Это вторая сторона медали, и мы о ней поговорим позже в этой
главе. Но так же, как и первый критический случай — когда вы просто делаете
что-то, не понимая зачем, попытка делать что-то идеально, зная и осознавая
минимум вселенскую красоту масштаба, вас буквально заставляет стоять на месте
или бегать по кругу.

В механическом же смысле принцип работает крайне просто:
Вместо того чтобы пытаться ломиться вперёд для того, чтобы решить какую-то
задачу, потому что она перед вами в принципе есть или возникла в результате
решения других задач, вы должны научиться останавливаться и задавать себе
вопрос — зачем вы это делаете?

Вместо того чтобы пытаться понять и осознать базу строения сложных механик,
изучить десяток фреймворков, освоить тысячи подходов, вы должны научиться
останавливаться и задавать себе вопрос — что вам это в итоге даст?

Фактически принцип говорит о том, что вы должны научиться останавливаться,
сравнивать свой путь с адекватным и менять его после этого без сожалений.

Таким образом, не превращаясь в идеалиста и мечтателя, а выдерживая в себе
чувства прагматизма и реальности.

## Принцип преимущества эволюции над креационизмом:

Второй принцип возникает буквально из того, что вы видите вокруг себя
постоянно и каждый день. О том, как эволюция побеждает идеальные системы.

В чём цикл эволюции:
- Создать систему
- Запустить её в среду, где она будет взаимодействовать
- После чего система умрёт (ожидаемо)
- После чего она будет создана заново с учётом эволюционных признаков, которые
  приобрела ранее

Это элементарная система, которая работает. Ни одного нет механизма вокруг
нас, который бы работал в плане эффективности также, эволюционный подход
победил буквально любой другой.

А к чему приводит непонимание этого принципа? К желанию создать что-то сразу
хорошо, чтобы это сразу работало, и чтобы это желательно развивалось так,
чтобы никогда не умирало.

И самое забавное и ироничное — что именно это и приводит к смерти проектов.
То есть борьба против эволюции приводит к наступлению эволюционного этапа
развития — то есть смерти.

Креационизм прекрасен как идея: идеальный первый шаг, идеальная абстракция,
написать идеальную систему авторизации.

Эволюция уродлива: написать систему, которая обеспечивает плюс-минус
безопасный вход с приложением минимальных затрат времени и ресурсов, чтобы мы
могли сосредоточиться на уникальных фичах. Так как в целом авторизация никому
не интересна.

Объяснять при таком подходе, почему первый способ не работает, а второй
работает, думаю, излишне.

Что здесь неочевидно, то что эволюционный подход изначально ущербен и заставляет
делать ущербные, кривые, но рабочие системы. Которые, проходя эволюционный
цикл, должны по определению умирать и возрождаться вновь, уже в чуть лучшей
форме. Замечу — не идеальной, а такой же кривой, но чуть лучшей форме, для
того чтобы потом снова повторить эволюционный цикл.

Это красиво? Конечно нет. Это уродливо и неэлегантно, это омерзительно, я бы
даже сказал.

Но понимание того, что вам именно такой путь и нужен, и делает вас
эффективными. Вы должны научить себя работать с отсутствием красоты,
целостности и элегантности. И стать по сути из локального бога для своих
систем чем-то вроде эволюционного инженера-селекционера.

## Принцип привязки к рыночной реальности:

Принцип по своей сути является развитием предыдущего и мог бы быть даже
включён в него, однако я выделю его в отдельный для того, чтобы показать его
значимость.

Принцип заставляет любую работу, направленную на продукт, быть коммерчески
значимой, так как по сути коммерческая значимость представляет собою
универсальное мерило эффективности как таковой, так как, имея деньги, вы
получаете возможность менять их на другие ресурсы.

Причём принцип может показаться не совсем адекватным для проектов опенсорс или
пет-проектов, но нет — и там он также находит свой отклик.

Например, опенсорс-проект для того, чтобы работать и развиваться, требует по
сути вокруг себя создание фаундейшн или иной формы организационной структуры,
которая будет заниматься взаимодействием с реальностью и развивать этот
проект.

А пет-проект требует коммерческой ориентированности буквально по той причине,
что может быть продемонстрирован как показатель квалификации его автора.

Отчего принцип диктует простое правило:

> Прежде чем что-то делать — подумайте, как это действие выльется в деньги.

Так как если вы так думать не будете, вы рискуете попасть в ловушку
идеалиста, то есть пойти тем путём, в котором денег точно никогда не будет.

Но у принципа есть ещё и вторая сторона: он заставляет взвешивать ваши
действия с эффектом на коммерческую составляющую, которую они оказывают. Так,
при слишком небольшом объёме действий и работы, вложенной в продукт, он будет
недостаточно ценным и денег приносить просто не будет — так как будет никому
не нужен. А при слишком большом объёме действий и работы, вложенной в продукт,
вы рискуете войти в зону так называемых невидимых и неэффективных улучшений,
когда работа, будучи вложенной в продукт, просто не будет приносить никакой
коммерческой отдачи.

Вот для того чтобы этого и не происходило, вы и должны определяться прежде,
чем что-то делаете, с тем, насколько это в целом эффективно или нет,
управляете ли вы продуктом самостоятельно или работаете в команде.

Так как правила всегда одинаковые. И ваша работа также является точно таким
же коммерческим продуктом, который вы продаёте.

Фактически принцип коммерции при его понимании и принятии позволяет
значительно абстрагироваться от бессмысленной борьбы с реальностью за
идеальные решения и начать делать ту работу, результаты которой возможно
продать.

## Принцип сосредоточенности на психическом здоровье:

Я в разных разрезах уже декларировал эту мысль, повторю её здесь также, но с
точки зрения эффективности.

Нет никакой ценности в гиперумном, гиперквалифицированном разработчике,
обладающем тысячами часов знаний, который сорвал себе психику, выгорел и всё,
что может делать, — это просто лежать и прокрастинировать.

Так как нет победы там, где вы внутренне проиграли. И нет победы там, где вы
доработались до того, что решили вашу ничтожность в моменте объявить победой
(а я думаю, вы понимаете, что я сейчас описываю, так как не раз видели
подобное).

Психическое здоровье должно соблюдаться с самого начала. И оно является
приоритетом на всех уровнях вашего взаимодействия и с продуктом в плане
разработки, и со средой, которая этот продукт окружает.

По своей сути психическое здоровье достигается двумя векторами:

Минимумом рефлексии (1), когда вы сосредоточены на том, как двигаться, вместо
того чтобы загоняться по поводу того, что у вас прямо сейчас происходит и в
каком месте вы находитесь. Так как провалы и спады буквально бывают у всех.

И максимумом делегирования в методику и механику (2), когда вы не смотрите на
результат, который вам не всегда полностью подконтролен (так как достигнуть
фантазию часто бывает не всегда возможно в том виде, как вы себе представляете),
а корректируете то, что вам подконтрольно:
- следование лучшим механикам
- и сосредоточенность на лучших методиках
- и соблюдение темпа движения
  Так как если вы всё бросили, какими бы ни были прекрасными ваши планы, они
  просто ничем не закончатся.

Проход через это понимание происходит у каждого разработчика — так как кризис
компетентности (и не только) для такой профессии это более чем нормально.

И второй момент принципа как раз об этом:

Не нужно сопротивляться такому переходу, вы должны принципиально для себя
пережить тот момент, когда старые неэффективные модели, к которым вы привыкли,
разрушатся и освободят место чему-то новому.

Проще говоря, основываясь уже на приведённых принципах:

невозможно быть идеалистом в мире коммерции — это будет разрушать ваше
психическое здоровье;
невозможно пропагандировать креационизм в разработке — это будет вас заставлять
чувствовать себя неполноценным;
и так далее.

Проще говоря, нарушение каждого из принципов эффективности будет нарушать в
том или ином виде ваше психическое здоровье и откатывать вас назад. Следование
этим принципам будет его вам возвращать.

Отчего вы, изначально ставя психическое здоровье в приоритет, должны понимать
аспекты, которые его разрушают или улучшают. И сосредотачиваться на них.

Потому что невозможно, работая инженером, не выгореть, такого просто не бывает.
Но можно пройти это выгорание правильно и снова вернуться к работе, если
ставить это в приоритет и начинать оперировать процессами (методологиями и
механиками) — а не результатами.

## Принцип переключений (два три дела одновременно):

Этот принцип по сути состоит из двух составных частей.

Первая часть говорит о том, что если вы занимаетесь каким-то одним делом или
задачей, особенно если она очень крупная, она вам гарантированно надоедает, вы
начинаете буксовать и в итоге скатываетесь до того, что эта задача начинает
двигаться черепашьим шагом, если вообще двигаться.

Причём это относится и к работе команд, и к работе отдельных разработчиков.

И единственный способ как-то избавиться от этого — это буквально добавлять для
разнообразия задачи, которые к начальной задаче не имеют прямого отношения или
слабо с ней связаны, для того чтобы давать ощущение разнообразия.

Причём для команд этот принцип настолько значим, что фактически руководителю
разработки должно быть поставлено в обязанность "развлекать" своих
сотрудников тем, чтобы разнообразить их работу.

Вторая часть принципа же пытается пресечь чрезмерное увлечение разнообразием,
когда у вас тридцать-сорок задач, они все крайне важны, и при этом вы только и
делаете, что занимаетесь их трекингом — без реального движения.

Она говорит об ограничении количества активных задач в разработке, желательно
подбиваясь под число две или три, так как увеличение количества задач будет
прямо пропорционально сказываться на снижении скорости их выполнения.

Но это не всё. Дело в том, что в этих исполняемых задачах потребуется ещё и
выделить основную задачу, с которой вы обязаны начинать свою работу, без
вариантов. Так как именно это и гарантирует движение общей линии прогресса при
работе над проектом.

Таким образом, механически принцип реализуется следующим образом:
1. Из общего пула задач взяли себе две-три самых основных на день.
2. Из них выделили себе основную и начали работу принципиально с неё.
3. В случае если над основной задачей надоедает работать, начали делать
   остальные.
4. Как только почувствовали, что силы к основной задаче вернуться появились,
   вернулись к ней.
5. Если прошло достаточно времени и вы не вернулись к основной задаче, всё
   равно вернитесь и сделайте по ней хотя бы какие-то минимальные действия, для
   того чтобы освежить её в памяти.

Как видим, механика требует понимания границ разнообразия. Потому что обе
крайности (слишком много задач, слишком мало задач) будут приводить к ощущению
"бега в колесе" и выгоранию.

Почему это работает на уровне вашего мозга? И зачем нужны несколько задач?
Дело в том, что у вас многие задачи решаются мозгом пассивно, то есть ему
требуется какое-то время для того, чтобы "придумать" решение. Таким образом,
вы не можете реализовывать решение и эффективно думать одновременно. Вам
требуется сначала подумать, потом поработать, потом опять подумать, потом снова
поработать, причём не просто подумать, а подумать пассивно, то есть просто
подержать задачу в своей голове. Если же думать активно, с помощью только
лобной доли, — эта процедура достаточно сильно выматывает. А вот переключение
в моменты "подумать пассивно" на другие задачи мы как раз и достигаем нашей
эффективности.

## Принцип выполнения работы корой больше чем лобной долей:

Принцип очень простой, если вы поймёте, что когда вы выполняете работу, вы
выполняете её либо той частью мозга, в которой эта работа и её выполнение
являются зазубренными, и сама работа воспринимается как повторение
(выполнение с помощью коры), либо той частью мозга, которой вы думаете и
анализируете, и где работа воспринимается как вычисление (выполнение с
помощью лобной доли).

Разница причём между вариантами выполнения работы колоссальна: та работа,
которая выполняется корой, — практически не требует напряжения — вы
выполняете её на автопилоте и, выполняя её, практически отдыхаете. А та часть
работы, которая выполняется с помощью лобной доли, требует огромного
когнитивного напряжения и заставляет вас сильно утомляться и перегружаться.
Более того, то чувство опустошённости, которое вы испытываете, вызывается
именно такого рода работой.

Как же сделать так, чтобы работа выполнялась не лобной долей и снять с неё
нагрузку? Очень просто:
- доводите те блоки работы, с которыми вы сталкиваетесь, до механического
  запоминания,
- как бы это глупо изначально не звучало.
- именно этим вы и будете снимать с себя нагрузку и будете переставать
  уставать.

Механически же это работает через активное повторение: где вместо того, чтобы
прочитать книгу один раз, не поленитесь и перелистайте её, делая пометки, а
лучше, если есть время, перечитайте. Аналогично, если вы прочитали статью по
нужному вам топику, а если же у вас есть время, напишите конспект. Возьмёте
себе это за привычку, и по факту в итоге вы перестанете за рутинные действия
расплачиваться высокой перегрузкой, и жизнь ваша станет значительно проще.

## Принцип монотонного цикла против мотивационного всплеска:

Принцип достаточно прост для понимания, но достаточно сложен для освоения и в
сути своей звучит так:

> учитесь работать без мотивации

Вам не хочется работать? Самое время начать.
Получится всё не так, как хочется, и медленно. Это именно то, что нам и нужно.
Не захочется работать долго? Ну так поработайте значит недолго.

Здесь нужно понять одну простую вещь, и я продемонстрирую её математически:
если в течение недели вы кое-как будете работать над каким-то проектом по 60
минут в день, к концу недели у вас будет отработано — семь часов, а это почти
полный рабочий день.

При этом эта работа будет точно так же сделана, как если бы вы раз в неделю на
высокой мотивации те же самые семь часов. Разницы нет буквально никакой.

Но в первом случае вы двигались абы как и пришли к результату, не страдали, не
изнуряли себя, а буквально монотонно двигались к цели понемногу. А во втором
ждали рывка и мотивации, так как семь часов подряд отработать — ну это прямо
совсем круто.

Дело в том, что принцип демонстрирует очень неочевидную часть эффективности:
быть эффективным — это не значит быть мотивированным, быть лучше всех в чём-то
или обладать какими-то сверхчеловеческими навыками.

Быть эффективным — это значит быть последовательным и монотонным. То есть день
за днём делать одно и то же из того, что вас движет к цели. При этом полностью
забыв о какой-то мотивации. Причём мотивация здесь не исключается — может
быть, в какой-то день ваших монотонных действий она и появится, ну и это
просто отлично — вы в этот день отработаете с мотивацией, как с редким гостем,
а в остальные дни вы будете просто работать. Без неё. Как получится.

Нет, я, конечно, не исключаю, что где-то живет тот самый человек, который
дождался мотивации, и у него всё получилось, но я, к сожалению, его не знаю, а
вы? Я думаю, тоже нет. Видимо, потому что его просто не существует.

Так зачем тогда навешивать на себя признаки того, чего даже не существует в
природе? Зачем тогда ждать мотивацию, может быть, ждать тогда уже сразу, как
работа выполнит сама себя? Я сейчас специально довожу это до абсурда, но у вас
в голове должно жёстко сейчас переключиться: вы должны приучить себя выполнять
работу без мотивации и без настроения. И при этом приучить себя делать её в
том виде, в котором получается её делать, даже если получается не так, как
хочется.

## Принцип достаточности в производимых решениях:

Достаточность решения подразумевает, что у вас есть бизнес-задача, которая вам
требуется для того, чтобы решение двигалось вперёд, и есть решение этой задачи
ровно на границе того, чтобы оно работало.

По сути, несмотря на достаточную жёсткость и некоторую неудобность написанного,
принцип пытается реализовывать правила "лучшее — враг хорошего" и так
называемой "бритвы Оккама".

Логика, стоящая за спиной принципа, крайне простая: если что-то уже работает и
решает проблему, — зачем делать это лучше (?), не проще ли сосредоточиться на
следующей задаче.

Да, решение будет не идеальным, да, мы будем получать негативный фидбек (что
не факт), но при этом это будет уже решением, оно будет реализованным, и ничто
не помешает нам при наличии достаточного времени и ресурсов привести его в
лучшее состояние, чем оно есть сейчас.

У принципа, помимо чисто материалистической составляющей, есть ещё и
психологическая: мозгу ставятся жёсткие рамки — сделать то, что работает, а не
то, что хочется, — ни больше, ни меньше.

А это уже понятная и осязаемая задача, заставляющая думать оптимизацией, а не
фантазиями того, как ещё в принципе можно сделать.

Третий не совсем очевидный момент этого принципа заключается в том, что на
уровне проекта целиком качество будет выше, так как у него будет больше
функциональности, и он будет более цельным, чем если бы в отдельном модуле
было бы качество чуть выше, но при этом остальных модулей просто не было бы в
наличии.

И как очень неочевидное понимание: сначала делай целиком, потом оптимизируй, не
наоборот. Просто потому, что если у вас два модуля и они реализованы на 60%
качества, и при этом проект работает, это будет лучше, чем если у вас один
модуль на 90% качества, а второй не реализован, так как не реализованный модуль
— это всё равно что модуль, сделанный с нулём качества.

Таким образом, кажущийся выигрыш на локальном уровне приводит к глубокому
проигрышу на глобальном. Хотя это и крайне неочевидно. И как итог: или у тебя
пользователи, которые тебя ругают (потому что ты что-то сделал неочевидно), или
тебя не ругают — потому что ты ничего не доделал.

(История же о том, что всё работает идеально, при этом всё доделано, как
понимаем, это история компании, которая в итоге после разработки обанкротилась,
так как это просто неэффективно.)

## Принцип сосредоточенности на плохих решения которые работают:

Принцип развивает предыдущий, однако в контексте отдельно исходного кода,
заставляя принимать легаси и неоптимизированный, но рабочий код в том виде,
как он есть.

Любой разработчик ненавидит легаси и чужие решения, так как они непонятны, не
оптимальны и некрасивы.

Однако принцип как раз заставляет думать иначе:

Легаси-код стал таковым не потому, что его неправильно писали, и не потому,
что разработчикам не хватало квалификации, а потому что им ставили бизнес-задачи,
которые последовательно возникали и которые этот код раз за разом итеративно
решал.

А выглядит он уродливо по той причине, что невозможно создать десятки мегабайт
кода и сделать его хорошим, так как ошибки и проблемы способны лишь только
накапливаться — это естественный путь, и иначе быть не может (это называется
красивым термином "энтропия в разработке").

Любая попытка создать код большого объёма будет создавать ровно такие же
проблемы, каким бы продвинутым и умным ни был бы разработчик. Это неизбежно.
Так как идеальный рабочий код может быть лишь только либо в мизерной
реализации, либо в фантазии.

Отчего качество легаси нужно принимать не по принципу "плохо выглядит", а по
принципу "работает и выполняет ли поставленную задачу или нет". Не больше, не
меньше.

Так как боль от адаптации всегда будет ниже, чем боль от создания чего-то
нового полностью с нуля.

Отчего решение, которое выглядит плохо и работает эффективно. А умение
принимать это — признак зрелого разработчика.

Эффективная архитектура же, как и было описано в прошлых главах этой книги,
строится не на том, чтобы делать всё хорошо, а на том, чтобы быстро
умерщвлять то, что плохо работает, заменяя это тем, что работает чуть лучше
(опять же ни в коем случае не идеально).

Отчего любое решение в моменте, которое вы создаёте, будет всегда недостаточно
хорошим, и любое решение, которое вы будете адаптировать, также будет
недостаточно хорошим, но если они в комбинации работают, — это решение
эффективно, и к такой комбинации и надо стремиться.

Принцип работает и строится на ряде достаточно известных теоретических
принципов и правил (что совсем неочевидно):

1) Принцип Парето — говорящий, что не нужно тратить на оптимизацию и приведение
   в порядок 20% проекта, тратя на это 80% ресурсов (что неизбежно).
2) Принцип эвристики — говорящий, что незачем просчитывать все варианты пути,
   тратя на это время и ресурсы, когда вы можете построить путь плюс-минус
   работающий и доводящий вас до цели (не идеальный путь).
3) Общий принцип эволюции — говорящий, что сохранение в теле рудиментов — это
   здоровый путь эволюции, например, в теле человека есть аппендикс и копчик.
4) Общий ориентир на реальность — плохие и неполноценные решения, как ни
   странно, получают больший фидбек от реальности, позволяя себе быстрее
   эволюционировать, так как недостатки видно быстрее и сразу.

## Принцип идентификации ошибки (антифрустрация):

Принцип передаёт очень простую мысль:

Если невозможно идентифицировать ошибку, невозможно сказать, работает система
корректно или нет. А сама же ошибка, для того чтобы её было возможно
идентифицировать, должна быть выражена как расхождение между сценарием,
переданным тестом, и реальным исполнением.

Таким образом, заставляя тестировать не просто работу отдельно взятого метода,
а работу метода в рамках бехевиорального теста (то есть бизнес-кейса с таблицей
данных, передаваемых такой сценарий в цифрах), как раз именно для того, чтобы
установить и идентифицировать ошибку и отреагировать на неё.

Если же теста не будет, — система станет неконсистентной и будет работать как
угодно, а работает она с ошибкой или нет, мы этого просто никогда не узнаем,
так как просто не будем иметь опоры на то, что нам надо смотреть, и что
требуется улучшить и доработать.

Таким образом, ключевая мысль здесь:
- напиши сценарий, который ты хочешь видеть: всегда начинай с именно этого
- передай его в виде бехевиорального теста: но делай это только после имеющегося
  сценария
- и задай данные для такого теста: для того чтобы была возможность сравнивать
  реальность и исполнение
- после чего сделай реализацию
- таким образом ты сможешь увидеть и идентифицировать ошибку
- и исторически отследить развитие системы

Пропустишь сценарий, выраженный в тесте, — ошибка просто не сможет быть
идентифицирована, и ты будешь испытывать бесконечную фрустрацию, так как
система вроде бы перед тобой, вроде бы будет что-то делать, но почему-то делать
не так, и будет при этом непонятно, как её двигать в развитии вперёд, так
чтобы она делала то, что тебе нужно.

Отсюда же идёт и понимание того, что написание тестов просто для проверки
того, что методы работают в том виде, как они есть, особенно после написания
таких методов, — в целом бесполезно, так как не позволяет эскалировать ошибку
до бизнес-сценария и таким образом идентифицировать её именно там, где она и
является ошибкой в логическом смысле.

Ещё один неочевидный инсайт здесь заключается в том, что пустой бехевиоральный
тест, выдающий ошибку на 100%, как раз и заставляет нас делать реализацию,
которая эту ошибку покрывает, таким образом являясь путём к развитию системы.
Что по сути и убирает фрустрацию, так как по сути вся ваша работа сводится к
тому, чтобы раз за разом из системы ошибки убирать.

## Принцип признания совершения ошибок и исправления их вместо создания иллюзий:

Принцип развивает предыдущий, однако добавляет более глобальную связь с
реальностью, так как касается не просто кодирования, но и организации и ведения
работы в целом.

Развитие прошлого принципа заключается в том, что изначально, прежде чем
как-то работать с ошибками, нужно научиться их идентифицировать, и это всегда
будет первым шагом.

Инсайд же, который добавляет именно этот принцип, заключается в том, что без
ошибок движение вперёд просто невозможно. Это связано с тем, что реальность
слишком сложна для того, чтобы любое решение, каким бы изощрённым и спланированным
оно бы ни было, не столкнулось бы с недостатками в процессе взаимодействия со
средой.

По сути принцип говорит:

Ты совершаешь ошибки, ты реагируешь на отклонение, ты идёшь исправлять
последствия, и благодаря этому процессу постоянно движешься дальше.

Или ты совершаешь ошибки, не признаёшь их ошибками (или просто не
идентифицируешь), заходишь в тупик и испытываешь там бесконечную фрустрацию.

Первая позиция требует честности с собой и признания своих недостатков, однако
ведёт вперёд. Вторая позиция делает глубокий комфорт на уровне эго, но при этом
превращает тебя в жителя сказки, которую ты сам себе придумал.

Первая позиция говорит:
- Ошибки — это просто данные, даже если это касается лично меня самого как
  человека.
- Разбирать, почему система дала сбой, интересно, совершенствовать систему
  интересно.
- Нужно установить, почему система дала сбой.
- Почему моя гипотеза была некорректной?
- Моя задача — найти инструменты и средства для того, чтобы сдвинуть систему
  вперёд, при этом выдержать решение грубым и простым.

Вторая же позиция буквально токсично шепчет:
- Ошибка — это пятно на репутации.
- Её нельзя признать, её надо скрыть, оправдать, переложить на других или
  утонуть в стыде.
- Я должен защищать свой образ компетентного и идеального человека, даже если
  это значит остановиться и ничего не делать.
- Лучше ничего не делать и как следует всё продумать.

Очевидно, что первый путь ведёт вперёд. Второй же не просто не ведёт никуда,
он делает вас и вашу работу только хуже.

По сути принцип требует:
1. Признать реальность и наличие ошибки, более того отнестись к этому как к
   здоровому процессу.
2. Гордиться тем, что вы делаете ошибки, так как это движет вас вперёд,
   буквально.
3. Совершить минимальные действия для исправления ошибки, так чтобы её
   последствия перестали оказывать влияние на систему в целом.
4. Провести эксперимент и посмотреть, исчезла ли ошибка или нет.
5. Стараться исправлять ошибку в корне (следующий принцип).
6. Не заниматься самокопаниями при попытке быть идеальным в неидеальном мире,
   сохранять фокус на цели, а не на своей выдуманной репутации или роли.

Ключевой инсайд здесь заключается в буквально совмещении психологии с
инженерным процессом на флоу:
- сценарий — тест — идентификация — коррекция
- пропустив даже один из этапов, вы сделаете систему стоящей на месте и не
  развивающейся,
- что очевидно — если это так показывать, и не очевидно — если показывать
  каждый из компонентов в разрыве,
- а если вы в вашей жизни или работе зависаете во фрустрации, возможно, вам
  стоит посмотреть на окружающее вас именно с инженерной точки зрения, особенно
  если вы инженер.

Так как представьте себе код, который вместо того чтобы проходить тест,
старается его игнорировать или обманывать, какие перспективы у такого кода? А
у человека, который делает то же самое?

## Принцип отказа от описания последствия и сосредоточенности на причинах:

Опять же, этот принцип также развивает предыдущий, но конкретно в поиске
причины каждой ошибки.

Так как, как мы понимаем, нет ничего более занимательного, чем разбираться с
последствиями и не искать причины, это фактически обеспечение себя бесконечной
работой.

Причём, если с инжинирингом вопрос снимается достаточно легко процедурой
разработки, как раз базирующейся на тестах, и рассмотренной в принципах выше,
то вопросы с психологией и отношением к работе чуть менее понятны, хотя
достаточно объясняемы:

Так, вместо:
"я перфекционист" -> поэтому у меня паралич
и
"я в выгорании" -> поэтому у меня нет энергии
и
"я не знаю" -> поэтому я бездействую

учимся оперировать чем-то реальным и осязаемым, как то:

Вместо "я перфекционист" учимся говорить себе: "я обычно трачу три часа на
выбор идеальной цветовой схемы для кнопки, которая даже не влияет на
функциональность".

Вместо "я в выгорании" учимся говорить себе: "я не умею организовать рабочий
день, поэтому или работаю по двенадцать часов без перерыва, или просто
прокрастинирую, после чего опять работаю двенадцать часов, и цикл повторяется".

Ну и вместо "я не знаю, что выбрать" учимся говорить себе: "я откладываю
решение между бэкендом и фронтендом, пока не изучу их досконально, хотя я
понимаю, что это невозможно".

Поиск начальной и базовой причины — процесс крайне простой, и всё, что требует
от вас как от разработчика в частности и человека в целом, — это задание себе
правильного вопроса о происхождении того или иного события.

Так как к событиям обычно подводится какой-то а) сценарий, который можно
измерить, б) с помощью теста, после чего в) для того чтобы исправить ошибку,
г) ввести коррекцию. Этот флоу всегда одинаков, более того, он по сути
передаёт "научный метод", просто в инжиниринге софта он более очевиден, а в
вашей жизни нет. Но как видим, его легко освоить и в вашем случае понять.

Не освоив же его, вы будет просто неэффективно тушить раз за разом пожары и
расстраиваться тем, как маленькие последствия накапливаются вокруг вас и
превращают не только разработку, но и остальную вашу жизнь в болото.

Вторая составная часть принципа здесь не самая очевидная — это потребность
атаки процесса, создающего первопричину ошибки, а не ярлык, который обычно
передаёт последствия.

- "программа медленно загружается" — это ярлык.
- "слишком много кода отвечает за загрузку" — это процесс.

Бороться с первым невозможно, бороться со вторым — как очевидно.

Перенося же это на вашу жизнь:
- "потратить три часа на раскраску кнопки" — это ярлык.
- "не умею выбирать первую попавшуюся подходящую" — это процесс.

Принцип работы точно такой же.

Смотрите внимательно:

- Ярлык (нет первопричины — решение не корректно):
  "я не умею общаться с людьми" -> последствие, "решение" -> не общаться.

- Процесс (явная первопричина — решение корректно):
  "я не знаю, о чём с людьми общаться при разговоре" -> процесс и решение ->
  посмотреть на ютубе видео, как вести small talk, на 45 минут времени,
  попрактиковаться хотя бы 30 минут перед зеркалом.

И это, как видите, чистейший инжиниринг.

## Принцип принципиальной опоры на чужие решения (поддержание точки назначения разработки):

Принцип демонстрирует одну очевидную вещь: рабочее время команды, ведущей
разработку, конечно. Она может или выбрать реализацию фич, или выбрать
реализацию поддерживающей инфраструктуры.

Выбирая одно, команда отрезает буквально время от другого. Из неочевидного
здесь то, что команда, когда выделяет время на реализацию какого-то
инфраструктурного решения, не понимает, что это решение не просто придётся
реализовать, но и активно поддерживать. А часто бывает так, что создать
версию 1.0 — это плюс-минус десять процентов работы, остальное время же — это
развитие и поддержка следующих версий (логирование, тесты, интеграции,
документация, освоение новыми сотрудниками, копящийся техдолг и рефакторинг,
работа менеджеров проектов, задачи в таск-трекере, ошибки и баги, и так
далее, и тому подобное).

И вот здесь должно приходить реальное понимание того, почему требуется
использовать в разработке чужие решения. Так как это буквально делегирование
потенциальной работы вовне команды, которая задействована в проекте, и
сосредоточение её на бизнес-фичах, вместо того чтобы сосредотачиваться на
том, что другая команда, пусть даже и хуже (!), но делает параллельно.

Принцип может быть представлен и чисто механически простым делением часов:
команда или отдельный разработчик закладывают на работу над инфраструктурой,
например, десять процентов от общего времени работ. Вот всё, что не успеется в
это время сделать, будет просто невозможно. Это сразу же открывает глаза на
то, что придётся заимствовать чужие решения и адаптировать их.

Как мы понимаем, психологический аспект здесь существенен: разработчику
всегда кажется, что он что угодно сможет сделать лучше, глядя лишь на
недостатки и косвенно глядя на внутреннюю сложность продукта. Однако простая
логика в мышлении и осознание того, что вот это "плохо" было сделано за
десятки тысяч часов, и вам придётся проделать плюс-минус такую же работу от
попытки изобретения подобного велосипеда, лечит. Ну, а про кривизну чужого
решения я уже говорил в этой главе, чаще всего это не ошибка, а принятые
компромиссы.

Проще говоря, в 99 процентах случаев сделать: быстро, красиво и как надо —
не выйдет, а закончится всё тем, что значительная часть кодовой базы проекта
не будет посвящена проекту и тем идеям, которые в него заложены, а будут
представлять собою переизобретение того, что уже в мире вокруг есть и уже
работает.

Следующий неочевидный момент здесь — это понимание того, во что развитие, по
сути, сайд-проекта выльется в итоге. Потому что ответить на вопрос о будущем
скорее всего не выйдет, а возможен скорее всего кейс, когда будет замена на
принятое решение, и в этом случае будущее буквально станет — заморозить и
удалить.

По сути, если описывать кратко происходящее, то выбор локальной оптимизации
будет гарантированно вести к глобальной катастрофе проекта, оттягивая силы от
его развития в сторону невнятных дублирующих решений.

И опять же неочевидная механика: прежде чем делать что-то самостоятельно,
потратьте время и проверьте, проведя качественный рисеч, не изобретаете ли вы
аналог того, что уже на рынке есть и уже работает. Если именно это и
происходит, остановитесь — и переходите к интеграции, вместо написания с
нуля.

## Принцип отказа от поддержания n! сложности в решениях:

Я уже в разных разрезах говорил о том, как n! оказывает влияние на проект,
здесь же мы поговорим о чистой механике её избегания.

Понятно, чем заканчивается ведение работ и планирование на базе n!: когнитивным
стопом и сразу за ним полной остановкой работы, или, как вариант, если
разработчик один и делает свой проект, — то человеком, который "страдает, но
ползёт" с собственным раздутым сервисом, передавая таким страданием
"величие" своего проекта и свою "избранность" (я думаю, мы все это видели).

Как этого избежать: принципиально не допускать того, что система будет слишком
крупной в своих деталях и компонентах (они будут принимать на себя слишком
много сложности). А также связи внутри системы будут либо только сверху вниз,
либо разорваны через цепочки событий и специально выделенные для этого
менеджеры.

Таким образом, система, которая хочет, чтобы на событие отреагировали А и Б,
будет просто слать это событие в менеджер и останавливаться на этом. А реакция
А и Б будет на их личной совести.

Что породит абсолютную линейность, не:

    Система -> шлёт событие в А -> шлёт событие в Б -> А реагирует -> Б
    реагирует (а тут ещё может А реагировать на обработку Б)

а элементарную цепочку:

    событие пришло
    А реагирует
    А шлёт в ответ событие в менеджера (или не шлёт)

Пример со сложностью сверху вниз же легко передаётся через структуру энтити:

    Энтити торговый центр
    имеет энтити этаж
    имеющий энтити магазин
    имеющий энтити товар

и никак иначе.

Магазин в этой структуре никак не может подняться на верхнюю часть иерархии,
он или в торговом центре на этаже, или никак. Потому что если захочется вынести
его на верхний уровень, это будет отдельная цепочка:

    Энтити торговый центр
    имеет энтити этаж
    имеющий энтити магазин_в_торговом_центре
    имеющий энтити товар_магазина_в_торговом_центре

    Энтити магазин_отдельный
    имеющий энтити товар_магазина_отдельного

Это может выглядеть с непривычки немного странно, но это именно то, чем и
является прямая иерархия, наследующая убирающая сложность n! (попробуйте
промоделируйте в голове, почему это именно так — и к чему приведёт, например,
если мы при сценарии, что магазин относится к торговому центру, введём ещё и
магазин, который относится рынку, и магазин, который относится к интернет-
магазину).

Кейс, доказывающий проблему и решение, очень простой: представьте, что вы
решаете проблему с помощью TYPE для энтити магазин, но у вас появляется API,
которое отвечает за аренду.
- Но при этом аренда есть в торговом зале,
- в магазине внутри магазина,
- и в магазине внутри рынка.

Это и есть по сути демонстрация n! взрыва сложности.

Альтернативный сценарий здесь — это сделать сложность опять линейной, введя
энтити "соединение торгового центра и магазина". Тогда иерархия опять будет
понятной:
- энтити соединения торгового центра и магазина
- ссылающаяся на энтити торговый центр
- и ссылающаяся на энтити магазин

Вернёмся к принципу: идея здесь декларируемая очень проста. Действительно,
существует сверхгениальная, не ворочаемая модель, в которой можно просчитать,
как объединить что угодно с чем угодно, и сделать это максимально эффективно.
Однако нахождение этой модели когнитивно настолько всегда сложно (НЕ
эффективно), что от неё приходится отказываться и строить немного уродливые и
не всегда эффективные структуры и порядки взаимодействия просто для того,
чтобы снизить когнитивную нагрузку на тех людей, кто это проектирует и
реализует.

Таким образом, мы жертвуем эффективностью в рамках системы как решения, но
получаем эффективность в рамках её разработки как процесса.

## Принцип неотвратимости результата при достаточном количестве усилий:

Принцип говорит о двух достаточно неочевидных вещах: всегда можно достигнуть
чего угодно, если приложить достаточное количество усилий (отчего если вы не
прилагаете усилий и не делаете, вы явно этого чего-то не достигнете).

Однако ни определить достаточное количество усилий, ни сроки достижения даже в
среднесрочном периоде при этом не выйдет. Просто потому, что на глобальном
уровне сроки и расчёты неустойчивы из-за фактора статистического накопления
ошибки (непредвиденные сложности, баги, меняющиеся требования и так далее).

И рассчитать достижение чего-то в срок, вовремя и в том виде, как
запланировано, можно лишь на крайне небольшом участке.

Поэтому у вас всегда при работе со среднесрочным и тем более долгосрочным
планированием есть выбор:
1) или сознательно идти на искажение объёмов траты ресурсов, достигая момента,
   когда результат будет всё-таки в итоге достигнут,
2) или идти на компромисс и заканчивать работу тем, что в итоге получается и
   удаётся достичь, потратив заложенные в план ресурсы и сроки,
3) или просто не выражать долгосрочные и среднесрочные цели в виде сроков и
   ресурсов.

Поэтому: результат неотвратим — да, безусловно, дорогу осилит идущий, но отказ
от расчётов неизвестного по сути в процессе пути будет нас уберегать от
фатальных ошибок.

И здесь есть следующий крайне неочевидный инсайд:
- как же делать разработку под сроки? это же основополагающий вектор
  направления технической работы точно и в срок.
- ответ очень прост: это работает на масштабировании, а не на разработке как
  таковой.

Когда вы берёте готовое решение, которое уже есть, и аналогичную к повторению
среду, в которой уже работали, после чего совмещаете первое со вторым, — вы
буквально не допускаете появления статистической ошибки планирования, откуда
ей взяться? Даже если проект огромный.

Но если же это не так, вам остаётся только аджайл — без вариантов.

## Принцип признания своей позиции в мире и признания себя его частью:

Принцип направлен как на реализацию проекта, так и на разработчика лично. Он
заставляет соизмерять то, что разработчик делает, чувствуя себя частью мира:
не рассматривать свои ошибки как индивидуально особенные, не рассматривать
свои проблемы как те, с которыми никто не сталкивался, и заставляет
ориентироваться на общий человеческий опыт больше, чем на попытку всё вокруг
построить с нуля.

Разработчик и проект живут в мире, где эволюция длилась тысячами лет.
Игнорировать эту эволюцию или рассчитывать, что мир вокруг подстроится вдруг
под вас лично, — зря не стоит. С другой стороны, мир дарит ресурсы и
возможности, которые могут изначально не нравиться, но делают вас
эффективными.

И по сути признание, что вы являетесь частью мира и этих процессов в нём
протекающих, и подталкивает вас для того, чтобы такими ресурсами и
возможностями пользоваться.

Не нравится ПМ — подумайте: а почему он в системе эволюционно возник?
Переосмыслите.
- Не нравится легаси — а в чём причина его возникновения? Переосмыслите.
- Не нравятся дедлайны — а из-за чего они возникли, не из-за недоработок ли на
  ранних этапах и халатного отношения к процессам? Переосмыслите.
- Не нравится то, куда вы пришли? — а не вы ли причина этого длинного пути,
  который вас сюда привёл? Переосмыслите.

Это очень простая ментальная модель:
- Вы не вырываетесь — вы часть большого целого.
- Идя против этого большого целого — вы получаете массу препятствий.
- Идя вместе с этим большим целым — вы получаете бесплатные ресурсы и энергию.

Быть частью системы — это не конформизм, это стратегическая адаптация, так как
требует в том числе значительной работы, и это в итоге эффективно.

И тут есть очень неочевидный психологический момент: почему в вашей фантазии вы
всегда главный герой, а не загнанный стажёр или растерянный обыватель? Очень
просто: фантазия — это компенсаторный механизм, и вот этот механизм накладывает
отпечаток буквально на всё, что в ней находится, в том числе на проекты,
которые вы планируете, восприятие чего-то вокруг, что вы производите, и
действия, которые вы в итоге делаете.

Отчего же не нравится реальность многим из нас? Очень просто, опять же, — там
всё не так. Но дело в том, что работа и проекты делаются как раз именно по
правилам реальности, то есть внешней системы, которой в вашей голове, где вы —
центр вселенной, просто скорее всего нет, или она не так ярко выражена.

Признание же того, что она существует и с ней надо как-то взаимодействовать,
снимает с вас как с разработчика целые плеяды психологических моментов,
которые делают вас и ваше мышление неполноценными и как итог неэффективными.

## Принцип стереотипичного мышления (плюс принцип решения вопроса нехватки компонентов):

Принцип коррелируется с простым правилом работы мозга любого человека, — и
даже генеративных моделей ИИ, — способности держать в контексте лишь небольшое
число объектов для оперирования, а при включении слишком большого разнообразия
— падения эффективности решений или даже заваливании таких решений.

Принцип диктует простое правило: если ты не можешь держать в голове и далее в
системе что-то разнообразное, держи что-то однообразное и оперируй этим.

Даже если это однообразие и будет накладывать некоторую ригидность на решения,
которые ты будешь вырабатывать, так сложность сведётся к выработке
однообразных абстракций (стереотипов), и сложность самой системы деградирует
ровно до их уровня, так как они всегда будут вести себя плюс-минус одинаково.

Отсюда же появляется неявный момент: в случае, когда стереотипов не хватает,
не нужно сосредотачиваться на создании какого-то эксклюзивного кода, нужно
сосредоточиться на создании очередного стереотипа, который в дальнейшем можно
будет переиспользовать.

Например, у нас есть потребность перехватывать логирование и отправлять его в
брокер сообщений. С одной стороны, кажется, что это исключительно локальная
задача, которую можно просто решить. Но нет: за этой локальной задачей
последует следующая локальная задача, потом следующая, сложность решения резко
прыгнет вверх, и оно станет неуправляемым.

Поэтому вместо локальной правки делаем абстракцию "перехватчик логирования" и
делаем его стереотипом.

Теперь нам не нужно мыслить локальными реализациями, мы мыслим отдельным
first-class subject нашей системы. Нам нужно перехватить логирование — мы
используем перехватчик логирования. Как он работает внутри? Нам всё равно —
сложность скрылась за стереотипом, отчего разработка стала эффективной.

Причём замечу, ловушка на первом этапе добавления бизнес-логики себя не
проявит, всё будет хорошо, и даже на втором этапе проявит, но очень слабо.
Ворота же в ад n! сложности откроются, когда в одном коде будет 3–4 и больше
веток, относящихся к разным процессам.

Проще говоря: LoggingInterceptor.intercept(ClassName.class) — эффективно (1
чанк в контексте памяти), а цепочка if/else с ростом итераций — ведёт в ад (N
чанков, перегружающих контекст). Ловушка в том, что на первой итерации кажется,
что if/else — проще. Но уже на второй-третьей цена загрузки контекста
становится неподъёмной (и это же, кстати, и объясняет, почему LLM пишет плохой
код).

Научной основой этого принципа является число Миллера: 7 плюс-минус 2 объекта
в рабочей памяти. Однако здесь не всё так просто: дело в том, что стереотипов
может быть в системе значительно больше. Но вопрос не в том, сколько их вообще,
вопрос в том, что вы, решая рабочую задачу, каждый раз выбираете как раз 7
плюс-минус 2 стереотипа, которыми она решается, и всегда знаете, чем
оперируете.

## Принцип антиусложнения (сначала хорошо потом идеально):

Речь в принципе идёт, как ни странно, даже не о создании полноценных систем, а
о планировании к работе чего угодно, даже черновиков.

Он диктует простую цепочку жизненного цикла всего, что вы делаете:

Сначала решение работает, реализуя одну базовую задачу базовым способом,
потом оно решает эту базовую задачу полностью, но не эффективно, потом оно
решает набор задач, представляющих собой уже законченную бизнес-логику,
которой можно оперировать, и лишь потом у нас следует хотя бы какая-нибудь
оптимизация.

Как видим, принцип на самом деле достаточно практичный и диктует по сути
механику, которую можно свести к тому, что система, которая решает 80%
проблем сегодня, в миллиарды раз ценнее, чем система, которая обещает решать
100% проблем, но потом и когда-нибудь.

Сначала мы делаем прототип, который чуть живой, начиная от самых базовых
функций, и только после того, как система работает как система, начинаем её
улучшать.

Здесь происходит огромное перехлёстывание на всех уровнях с другими
принципами, уже описанными ранее, однако основная идея здесь именно о том,
что первичное решение делается именно минимально рабочим, даже без закладывания
в него потенциалов к развитию, идущих дальше структуры (структура, как уже и
не раз говорилось, должна быть сразу готова к будущей сложности, так как она
является по своей сути логическим каркасом проекта, который вы строите,
наполнение можно поменять легко, структуру нет).

## Принцип антиперфекционизма и стратегического компромиса:

Мы уже в нескольких разделах обсуждали перфекционизм в этой главе, здесь же мы
обсудим его в рамках принятия стратегического компромисса и того, что
перфекционизм представляет на фоне такого компромисса.

По сути, откуда берётся антиперфекционизм? — из реализма.

Мы буквально понимаем, что существуют две реальности. Одна находится
исключительно у нас в голове, где мы:
1. Отрицаем законы природы, и нам кажется, что всё как-то само собой сложится
   и нам повезёт.
2. Не смотрим на наши достижения и работы до момента взятия за конкретную
   задачу (например, мы всегда работали 2 часа вечером и ленились, но ставим себе
   задачу, которая подразумевает отработку 3+ часов, что противоречит
   историчности наблюдения).
3. Подразумеваем магические свойства, где мы работаем без перерывов по десять
   часов в день, ни на что не отвлекаясь.
4. Сталкиваемся с нулевой энтропией и полным отсутствием проблем.
5. Подразумеваем, что решение n! по сложности задач делается легко и просто.

Это первая реальность.

И вторая, собственно, это "реальная" реальность, где мы можем работать
вечером один, максимум два часа, и то не каждый день.

И как ни странно, всё происходит ровно по сценарию "реальной" реальности, и
она побеждает. А если человек загоняет себя в рамки реальности первой, он
впадает в кататонический шок и просто останавливается, так как разочаровывается
и в себе, и в окружающем мире, и в своих способностях.

Притом не понимая простой вещи, что если уж он начал мечтать, то мог бы
мечтать до конца и ни в чём себя не ограничивать — например, проект создавал
бы не программированием, а силой мысли, а потом лазерами из глаз делал бы его
дистрибуцию каждому потенциальному пользователю прямо в устройство.

Звучит глупо? Конечно, перфекционизм потому что и есть глупость. Оперируя
вторым сценарием изначально, то есть будучи реалистом, вы будете выбирать
инструменты, на которые есть время, и решения, которые можете сделать, отчего
они реально будут делаться. Оперируя первым сценарием, вы пишете историю-
сказку, которая никогда не станет реальностью.

А теперь о стратегическом компромиссе. Всё же начинается не с разработчика, а
с отдельно взятого проекта. Вот стратегический компромисс как раз и заставляет
сдвинуть его содержание к реальности, упростив его и сделав достижимым,
ориентируясь именно на реальность.

Более того, ещё и привязав его реализацию к уже перечисленным принципам,
например, сделав его разработку эволюционной и итерационной вместо попытки
спланировать его в виде грандиозного технического задания целиком.

Механически описанное выглядит так:
1. Мы берём проект или задачу.
2. Думаем о реальности, в том числе вспоминаем историю того, как делались
   проекты теми ресурсами, что предполагается использовать, и в новом проекте или
   задаче.
3. Видим признаки перфекционизма.
4. Обязательно устраняем их с помощью стратегического компромисса.
5. Получаем реализуемый плюс-минус проект (то есть это не гарантирует, что
   проект не провалится, но он хотя бы после такого будет адекватно двигаться к
   завершению).

Вообще же принцип можно свести к простой русской поговорке: 

> бери ношу по себе, чтобы не падать при ходьбе.

## Принцип любви и страха к проекту в частности и работе в целом:

Принцип показывает принципиальную разницу того, как вы готовите проект: что
этот проект для вас — это любимое дитя, которое вы лелеете и жалеете, даёте
ему всё только самое лучшее, или это солдат, который идёт воевать на войну и
которому нужна защита, чтобы просто не умереть.

Как итог: в первом случае вы вынуждаете себя работать над проектом
энергозатратно и неэффективно, во втором случае вы вынуждаете себя
пересматривать множество решений просто даже на фазе проектирования.

Проект вдруг основной целью должен быть не технологическим чудом, а
зарабатывать деньги. Он вдруг должен не нести в себе гениальные разработки, а
писаться на стандартных технологиях, чтобы можно было найти разработчиков,
которые его будут поддерживать, и так далее.

Причём подобный подход относится, как и звучит сам принцип, не только к
проекту, но и к вашей работе в целом. Вы можете сделать её максимально
эффективной по взаимодействию с окружением (так как взаимодействие с
окружением и делает что-то эффективным), или можете сделать её наивной,
стремясь уберечь от сложностей жестокого мира, который окружает вас вокруг.

И тот, и другой путь вам доступен. Они просто задают разные вопросы:
- А достаточно ли это красиво? А оценят ли это коллеги? А не обидим ли мы наш
  прекрасный код?
- против
- А выживет ли это в бою? А смогут ли это поддерживать? А принесёт ли это
  деньги?

Но выбирать с точки зрения эффективности придётся именно подход, основанный
на страхе, а не на любви. Любовь рождает музейные экспонаты. Страх рождает
работающие системы.

## Принцип доминирования методик над целями и планами:

Принцип говорит об очень очевидной, если это увидеть, и неочевидной, если
сознательно застилать себе глаза, вещи: из-за особенностей накопления
статистических ошибок даже среднесрочный результат никогда не будет
соответствовать ожиданиям, тем более долгосрочный.

Таким образом, когда вы планируете от результата, вы сознательно обрекаете
себя на страдания и на разочарование, так как он в большинстве случаев просто
к срокам планирования не будет достигнут или будет достигнут не в том виде,
как изначально задумывалось.

И от этого рождается методика управления собственной мотивацией и мотивацией
команды: принципиально не ставить себе целью результат, как бы это странно ни
звучало.

А ставить методологию по достижению результата, то есть управлять тем, что
тебе подконтрольно, а не тем, что тобой было буквально выдумано. Это как раз
позволяет не терять мотивацию к движению и результаты воспринимать как
последствия применения методологий к работе.

Проще говоря, принцип сводится к простым правилам:
- управляй тем, чем можешь управлять, и не расстраивайся по поводу того, чем
  ты управлять не можешь;
- не питай иллюзий о будущем, сосредоточься на настоящем;
- динамики работы и чувства контроля достаточно для того, чтобы поддерживать
  мотивацию;
- результаты всегда являются следствием действий и методов, а для работы
  являются не больше чем ориентиром.

По сути, сведя в одно предложение, принцип выглядит так: твой KPI — это
следование методикам, а не достижение результатов, как бы странно это ни
звучало.

Пример использования принципа: наша методика — делать 3 BDD-теста в день и
код-ревью. Сегодня мы сделали 3 BDD-теста и сделали код-ревью — с точки
зрения KPI мы явно движемся вперёд, мы молодцы и контролируем процесс.
Фича — является лишь побочным следствием нашей методики.

Описывать, что будет, если это убрать и оставить: "нужно сделать фичу к
концу недели, несмотря на то, что ничего не готово", — я думаю, здесь не
стоит, все это видели неоднократно.

В первом случае — гибкость и мотивация, во втором — ригидность и выгорание.

## Принцип соизмерения возможностей и достигаемого результата:

Принцип развивает многие уже приведённые и заставляет буквально соизмерять
силы и ресурсы, имеющиеся для реализации проекта, и сам проект. Более того,
вводит чёткую метрику для такого измерения.

Так как реализация проекта определённой внутренней сложности является для
инженера не мотивационным, а квалификационным вопросом, прежде чем браться за
проект, следует определиться с уровнем сложности, которую он в себе в принципе
может нести.

То есть, прежде чем браться делать копию "второго фейсбука", нужно ответить на
вопрос: а делал ли инженер, который за это берётся, рабочий блог?

Принцип развеивает иллюзию того, что каждый может сделать каждое. Это так не
работает: каждый может сделать лишь либо то, что делал, либо то, что немного
отличается от того, что он делал до этого.

И простой факт признания этого и дарит эффективность, так как не даёт командам
буквально "надрываться", требуя от них невозможного. Потому что "сделай, как
умеешь", — не факт, что сделать что-то, что даже в принципе будет находиться
на минимальном уровне какой-то бизнес-ценности.

С другой стороны, делать что-то очень сложное методами, которые предназначены
для того, чтобы делать что-то очень простое, — так же будет заводить раз за
разом в тупик.

Проще говоря, прежде чем лезть на личный Эверест, задайтесь целью влезть на
личный холм, продумайте ваш опыт и двигайтесь к следующей цели, не выгорая и
сохраняя итерационность и эволюционное развитие, но уже не по отношению к
проекту, а по отношению к себе (или команде — если вы работаете командой).

## Принцип компонентности и итерационности процесса:

Принцип раскрывает механику итерационности при создании сложных систем — как
именно процесса — и буквально говорит:

- сложная система не собирается в один проход;
- она собирается из готовых компонентов;
- каждый из которых также состоит из готовых компонентов;
- из-за чего в отдельном месте сборки системы сложность всегда представляет
  собой комбинацию плюс-минус пяти-шести элементов, которые легко держать в
  памяти разработчику.

Попытка же избавиться от этого принципа приводит к тому, что система
представляет собой в момент сборки отдельного узла нечто пугающее и
неадекватное.

Если же брать разработку, принцип буквально превращает её из чего-то
монолитного и однородного в прохождение нескольких достаточно разнообразных
стадий:

1. вот пишутся user stories — они простые и понятные;
2. вот делаются ARD — это также короткая работа, они просты и понятны;
3. вот в систему добавляются нехватающие стереотипы;
4. вот делаются тесты и таблички к ним в кукумбере — не менее элементарная
   работа;
5. вот делаются тесты в системе;
6. а вот появляются энтити и сервисы без наполнения как структура — всё
   элементарно;
7. и вот по одному разделу в структуру вписывается код;
8. а вот итерация проходит раз за разом по каждому пункту систему улучшая.


- все этапы крайне короткие и понятные;
- поэтому они управляемые;
- поэтому и достигаемые.

Если же этот процесс воспринимать с конца на начало — не дробя его на
компоненты и не вводя итерационность, — система становится просто
невоспринимаемой и очевидно гарантирующей возникновение когнитивного ступора.

То есть, по сути, у вас как у разработчика всегда есть два варианта:
1. гениально сесть за работу и сделать её от начала до конца в едином порыве;
2. дробить работу как процесс на простые и управляемые компоненты, после чего
   итерировать по этому процессу.

Первый способ больше похож на творчество (не исключается, что он возможен и
недоступен). Второй — на работу.

В первом случае вы больше творец картины или музыкального произведения. Во
втором вы скорее эволюцию производите от рыбы до млекопитающего, в процессе
которого промежуточные особи отмирают одна за другой.

- Первый случай — работает иногда, отчего в нём есть риски.
- Второй случай — всегда, отчего рисков в нём нет. И он эффективен.

Очень неочевидная механика здесь лежит на мета-уровне — которая сильно связана
с математикой и которую нужно осознать: мы не можем планировать результат, так
как он нам изначально непонятен и обладает нерешаемой сложностью. Но мы можем
планировать процесс по его созданию, который в итоге и создаст когнитивно
нерешаемый результат. Так как неочевидные вещи и связи станут очевидными после
дробления процесса, они буквально возникнут сами собой, так как фазам нужно
будет каким-то образом друг с другом быть связанными. И вот эти "как-нибудь"
связи и породят решение n! сложности.

## Принцип привязанности к реальности, а не к фантазиям:

Принцип достаточно прост и передаёт механическую природу установки связи
проекта с реальностью. Фактически он заставляет думать реальными объектами
вместо выдуманных.

То есть, на момент когда мы придумали идеальную user story, мы должны задаться
вопросом: а есть ли реальный пользователь, которому это нужно? Почему бы с
реальным человеком не проверить, как он себя поведёт?

И так буквально во всём.

Мы придумали идеальную мегаабстрактную и суперпонятную модель для организации
кода, а мы её в реальности проверили на разработчиках? Им удобно?

Мы решили делать проект и решили увеличить количество фич силами той же
команды на 30%. А до этого момента исторически мы без увеличения даже
закрывали ли все задачи в срок? Или сроки проваливали? Мы что добавляем —
фичи или новые фейлы?

Итог принципа опять же передаётся русской поговоркой: "гладко было на бумаге,
да забыли про овраги".

Или более модным термином: reality-first инжиниринг, когда системы, которые мы
планируем и проектируем, сразу же выкидываются в реальность, не живя в
лабораторных парниковых условиях, даже если они не до конца готовы, просто для
того чтобы получить от реальности фидбек и сделать на базе этого корректировку.

Это не выглядит логично, но это эффективно, так как стоимость ошибок падает в
тысячи раз, и они все выявляются на ранних фазах.

## Принцип переноса (делегирования) сложности из головы внутрь оперируемых систем:

Принцип говорит по сути об одной простой вещи, развивая идею о связи проекта с
реальностью: сложность системы должна где-то находиться, для того чтобы
система в целом росла и в целом развивалась.

Сложность может находиться:
1. в документации — но тогда придётся за ней следить и переписывать раз за
   разом;
2. в голове разработчика — худший вариант, так как мы гарантируем n! сложность
   и когнитивный стоп;
3. в самой системе — лучший вариант, так как он адаптирован под реальность.

Причём, чем больше сложности внутри системы, тем очевидно меньше её в голове
разработчика и тем меньше когнитивная нагрузка.

И вот отсюда возникает понимание того, почему итерационная разработка на базе
законченных решений так важна: она раз за разом переносит сложность небольшими
порциями внутрь системы, не позволяя разработчикам загрязнять голову и
перегружаться.

И вопрос о том, как организовать систему, чтобы она читалась в итоге,
значительно более простой, чем вопрос о том, как планировать систему на
бумаге, — так чтобы она на бумаге (а считай в реальности в голове инженеров)
была идеальной, а потом медленно эскалировалась в код.

И вот эту читабельность задаёт стереотипизация и выбор чужих решений над
своими, когда какой-то объект, будучи просто чем-то, задаёт свойства этого
чего-то, позволяя себя идентифицировать внутри системы.

Так принцип развивается в следующее:
1. мы стараемся работать так, чтобы быть связанными с реальностью;
2. связь с реальностью и сложность, это обеспечивающая, переносится внутрь
   системы итерациями;
3. перенос делается на базе стереотипов и чужих законченных решений для того,
   чтобы не приходилось писать дополнительную документацию и тестов для того,
   чтобы демонстрировать исторически процесс работы;
4. мы понимаем, что спустя год разработки мы предпочтём читать тесты и смотреть
   в коде стереотипы, чем спрашивать друг друга и себя в том числе о чём мы
   думали, когда это кодировали;
5. мы не исключаем, что нам придётся писать документацию, но мы предпочтём в
   этот момент, чтобы она была скорее описательной, чем разъяснительной нам самим,
   как работать.

Антикейс здесь также очевиден: если вам приходится раз за разом объяснять
коллегам, почему ваш код работает так, как работает, место нахождения
сложности становится очевидным. И если внутри системы хранилище сложности
бесконечное, в вашей голове оно точно ограничено. Отчего эффективно переносить
сложность туда, где место не ограничено, вместо переноса туда, где оно в конце
концов, каким бы умным разработчик ни был, закончится.

## Подведем итоги:

- N! сложности — это сбой, когда наша модель пытается смоделировать всю мировую
  разом.
- Выгорание — это энергетическое банкротство от этой бесплодной попытки.
- Эффективность — это успешная тактика: не моделировать всё, а брать из
  мировой модели готовые, обкатанные "библиотеки" (физические законы, социальные
  conventions, готовый софт) и использовать их как чёрный ящик.
- Чужие системы — это возможность переносить сложность внутрь и фокусироваться
  на вашей.
- Легаси-код — это и есть сама мировая модель в её естественном,
  эволюционном виде.

Основные моменты, которые нужно вынести:

Новая система за полгода становится столь же кривой, как старая за пять лет,
потому что законы — те же.

- Вместо: «Надо писать чистый код!»
- Вы говорите: «Давайте писать понятно-грязный код. Код, энтропия которого
  измерена, локализована и имеет план утилизации».
- Вместо: «Давайте перепишем этот монолит!»
- Вы говорите: «Давайте найдём в нём самую гниющую часть, обернём её в
  саркофаг (антикоррупционный слой) и потихоньку будем отгрызать по кусочку, не
  пытаясь понять весь монолит целиком».

Ну что, мы закончили на этом с софт-скиллами, давайте теперь разбирать
технологию. Переходим к Java Spring фреймворку.
